varnames := ["GRAPH_0__", "GRAPH_1__", "GRAPH_2__", "GRAPH_3__", "DIFFS_0__", "DIFFS_1__", "DIFFS_2__", ];
generators := [()
, PermList([4, 3, 2, 1, 7, 6])
];
## AD 07/08
#############################################################################
##
## INPUT two literal vectors, i.e. list of integers between 1 and n^3
##
## OUTPUT two shortened literal vectors where the least significant pair
##        of every cycle is removed
##
## METHOD the two vectors represent bit-vectors and these will be ordered 
##        using lex. For example ABC compared with CAB. Here the third
##        position is least significant and will thus never decide about the
##        ordering of the two vectors. A pair of literals will be removed 
##        if everything other pair of the same cycle appeared before.
##

rule1 := function( v1, v2 )
    local i, newv1, newv2, pos, elm;

    newv1 := [ ];
    newv2 := [ ];

    for i in [ 1..Length( v1 ) ] do
        if v1[i] <> v2[i] then
            elm := v2[i];
            pos := Position( newv1, elm );
            while pos <> fail do
                elm := newv2[pos];
                pos := Position( newv1, elm );
            od;
            if elm <> v1[i] then
                Add( newv1, v1[i] );
                Add( newv2, v2[i] );
            fi;
        fi;
    od;

    return [ newv1, newv2 ];
end;

gen_constraints := function(list, varnames, a)
  local perm, i, j, vecs, set;

  set := [];
  for i in list do
    perm := ListPerm(i);
    perm := perm{[1..Minimum(Size(perm), Size(varnames))]};
    vecs := rule1([1..Size(perm)], perm);
    Append(set, [vecs]);
  od;

  set := Set(set);

  for vecs in set do
    PrintTo(a, "lexleq( [");
    for j in vecs[1] do
      PrintTo(a, varnames[j], ",");
    od;
    PrintTo(a, "], [");
    for j in vecs[2] do
      PrintTo(a, varnames[j], ",");
    od;
    PrintTo(a, "] )\n");
  od;
end;
GeneratorsBasic := function(GeneratorsList)

        return GeneratorsList;
end;

FullGroup := function(GeneratorsList)
        local g;

        g := Group(GeneratorsList);

        return Elements(g);
end;

StabChainGap := function(GeneratorsList)
        local g, StabRecord, NewGeneratorsList;
        
        g := Group(GeneratorsList);
        StabRecord := StabChain(g);
        NewGeneratorsList := StabRecord.generators;

        return NewGeneratorsList;
end;

StabComplete := function(GeneratorsList)
        local g, NewGeneratorsList, n, ElemList, NewGeneratorsListDup;

        NewGeneratorsListDup := [];
        g := Group(GeneratorsList);
        n := LargestMovedPoint(g);
        
        for i in [1..n] do
            ElemList := Elements(Stabilizer(g,i));
            Append(NewGeneratorsListDup, ElemList);
        od;
        
        NewGeneratorsList := DuplicateFreeList(NewGeneratorsListDup);
        return NewGeneratorsList;
end;

StabCompleteN := function(n, GeneratorsList)
        local g, NewGeneratorsList, ElemList, NewGeneratorsListDup;

        NewGeneratorsListDup := [];
        g := Group(GeneratorsList);
        
        for i in [1..n] do
            ElemList := Elements(Stabilizer(g,i));
            Append(NewGeneratorsListDup, ElemList);
        od;
        
        NewGeneratorsList := DuplicateFreeList(NewGeneratorsListDup);
        return NewGeneratorsList;
end;

OrbitComplete := function(GeneratorsList)
        local g, NewGeneratorsList, n, ElemList, NewGeneratorsListDup, RepElem, i,j;

        NewGeneratorsListDup := [];
        g := Group(GeneratorsList);
        n := LargestMovedPoint(g);

        for i in [1..n] do
            ElemList := Orbit(g,i);
            for j in ElemList do
                RepElem := RepresentativeAction(g,i,j);
                Add(NewGeneratorsListDup, RepElem);
            od;
        od;

        NewGeneratorsList := DuplicateFreeList(NewGeneratorsListDup);
        return NewGeneratorsList;
end;

OrbitCompleteN := function(n, GeneratorsList)
        local g, NewGeneratorsList, ElemList, NewGeneratorsListDup, RepElem, i, j;

        NewGeneratorsListDup := [];
        g := Group(GeneratorsList);

        for i in [1..n] do
            ElemList := Orbit(g,i);
            for j in ElemList do
                RepElem := RepresentativeAction(g,i,j);
                Add(NewGeneratorsListDup, RepElem);
            od;
        od;

        NewGeneratorsList := DuplicateFreeList(NewGeneratorsListDup);
        return NewGeneratorsList;
end;

StabChainME := function(GeneratorsList)
        local g, NewGeneratorsList, ElemList, NewGeneratorsListDup, bool, i, j, RepElem;

        NewGeneratorsListDup := [];
        g := Group(GeneratorsList);
        i := 1;
        bool := true;

        while bool=true do
            ElemList := Orbit(g,i);
            Print("Orbit:", ElemList, "\n");
            for j in ElemList do
                RepElem := RepresentativeAction(g,i,j);
                Print("OrbitRep:", RepElem, "\n");
                Add(NewGeneratorsListDup, RepElem);
            od;
            g:= Stabilizer(g,i);
            Print("Stabilizer:", g, "\n");
            i:= i+1;
            if g = [()] 
                then bool:= false; 
            fi;
        od;    

        NewGeneratorsList := DuplicateFreeList(NewGeneratorsListDup);
        return NewGeneratorsList;
end;
a := OutputTextFile("/Users/caj/temp/graph.minion.gapout", false);;
H :=FullGroup(generators);;
gen_constraints(H, varnames, a);
quit;
