/* Minion Constraint Solver
   http://minion.sourceforge.net
   
   For Licence Information see file LICENSE.txt 

   $Id$
*/

/* Minion
* Copyright (C) 2006
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version 2
* of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

#ifndef _CONSTRAINT_H
#define _CONSTRAINT_H

#include "constraint_abstract.h"

struct AbstractTriggerCreator;

typedef vector<shared_ptr<AbstractTriggerCreator> > triggerCollection;

#ifdef  FUNCTIONPOINTER_TRIGGER
#define PROPAGATE_FUNCTION void propagate
#else
#define PROPAGATE_FUNCTION virtual void propagate
#endif


/** \defgroup Constraints
  * A list of all the constraints in Minion.
  */

// \addtogroup Constraints
// @{

/// Base type from which all static constraints are derived.
class Constraint : public AbstractConstraint
{
public:
  Constraint(StateObj* _stateObj) : AbstractConstraint(_stateObj)
    {}

  /// Function which impose all the triggers generated by setup_internal, which shouldn't be changed.
  void setup();

  /// Gets all the triggers a constraint wants to set up.
  /** This function shouldn't do any propagation. That is full_propagate's job.*/
  virtual triggerCollection setup_internal() = 0;

  // In function_defs.hpp
  //virtual Constraint* get_table_constraint();

  /// Iterative propagation function.
  /** Can assume full_propagate is always called at least once before propagate */
#ifdef FUNCTIONPOINTER_TRIGGER
  PROPAGATE_FUNCTION(int, DomainDelta) {}
#else
  PROPAGATE_FUNCTION(int, DomainDelta) = 0;
#endif
  
  /// Checks if a constraint cannot be satisfied, and sets up any data structures for future incremental checks.
  /// Returns TRUE if constraint cannot be satisfied.
  /** This function is used by rarification */
  virtual BOOL full_check_unsat()
  { 
	cerr << "Reification is not supported by the " << constraint_name() << " constraint. Sorry" << endl;
	FAIL_EXIT(); 
  }
    
  /// Checks incrementaly if constraint cannot be satisfied.
  /// Returns TRUE if constraint cannot be satisfied.
  /** This function should not be called unless check_unsat_full is called first. This is used by rarification */
  virtual BOOL check_unsat(int,DomainDelta)
  { 
	cerr << "Reification is not supported by the " << constraint_name() << " constraint. Sorry" << endl;
	FAIL_EXIT(); 
  }
    
  /// Returns the reverse of the current constraint
  /** Used by rarification */
  virtual Constraint* reverse_constraint()
  { 
	cerr << "Reification is not supported by the " << constraint_name() << " constraint. Sorry" << endl;
    FAIL_EXIT();
  }
};


inline void Constraint::setup()
{
  triggerCollection t = setup_internal();
  for(triggerCollection::iterator it = t.begin(); it != t.end(); ++it)
  {
    (*it)->post_trigger();
  }
}

// @}
#endif
