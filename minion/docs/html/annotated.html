<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Minion: Class List</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li class="current"><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Class List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
  <tr><td class="indexkey"><a class="el" href="struct_abs_constraint.html">AbsConstraint&lt; AbsVarRef1, AbsVarRef2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_abstract_constraint.html">AbstractConstraint</a></td><td class="indexvalue">Base type from which all constraints are derived </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_abstract_trigger_creator.html">AbstractTriggerCreator</a></td><td class="indexvalue">Abstract Type that represents any <a class="el" href="class_trigger.html" title="The classes which are used to build the queue.">Trigger</a> Creator </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_and_constraint.html">AndConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a></td><td class="indexvalue">Var1 /\ var2 = var3 </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_any_var_ref.html">AnyVarRef</a></td><td class="indexvalue">Provides a method of wrapping any variable type in a general wrapper </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_any_var_ref___abstract.html">AnyVarRef_Abstract</a></td><td class="indexvalue">Internal type used by <a class="el" href="class_any_var_ref.html" title="Provides a method of wrapping any variable type in a general wrapper.">AnyVarRef</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_any_var_ref___concrete.html">AnyVarRef_Concrete&lt; VarRef &gt;</a></td><td class="indexvalue">Internal type used by <a class="el" href="class_any_var_ref.html" title="Provides a method of wrapping any variable type in a general wrapper.">AnyVarRef</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structarray.html">array&lt; _Tp, _Nm &gt;</a></td><td class="indexvalue">Struct <a class="el" href="structarray.html" title="struct array [6.2.2]. NB: Requires complete type _Tp.">array</a> [6.2.2]. NB: Requires complete type _Tp </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_back_track_memory.html">BackTrackMemory</a></td><td class="indexvalue">Provides a wrapper around <a class="el" href="class_new_memory_block.html">NewMemoryBlock</a> for backtrackable memory </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_bool_binary_s_a_t_constraint_dynamic.html">BoolBinarySATConstraintDynamic&lt; VarArray &gt;</a></td><td class="indexvalue">Specialised SAT implementation for just 2 variables </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_boolean_container.html">BooleanContainer</a></td><td class="indexvalue">Container for boolean variables </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_bool_less_sum_constraint_dynamic.html">BoolLessSumConstraintDynamic&lt; VarArray, VarSum, VarToCount, is_reversed &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_bool_var_ref__internal.html">BoolVarRef_internal</a></td><td class="indexvalue">A reference to a boolean variable </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_bounds.html">Bounds</a></td><td class="indexvalue">A simple wrapper for a pair of bounds </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_build_con_1_1_build_con_obj.html">BuildCon::BuildConObj&lt; constraint, size &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structcompiletime__val.html">compiletime_val&lt; i &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_constant_constraint.html">ConstantConstraint&lt; truth &gt;</a></td><td class="indexvalue">Var1 /\ var2 = var3 </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_prob_spec_1_1_constraint_blob.html">ProbSpec::ConstraintBlob</a></td><td class="indexvalue">Constructed by the parser. Suitable for holding any kind of constraint </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_difference_constraint.html">DifferenceConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a></td><td class="indexvalue">|var1 - var2| = var3 </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_div_constraint.html">DivConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a></td><td class="indexvalue">Var1 / var2 = var3 </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_domain_delta.html">DomainDelta</a></td><td class="indexvalue">Represents a change in domain </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_dynamic_trigger.html">DynamicTrigger</a></td><td class="indexvalue">This is a trigger to a constraint, which can be dynamically moved around </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_element_constraint.html">ElementConstraint&lt; VarArray, IndexRef, VarRef &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_element_constraint_dynamic.html">ElementConstraintDynamic&lt; VarArray, Index, Result &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_empty_type.html">EmptyType</a></td><td class="indexvalue">A placeholder type </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_g_a_c_table_constraint.html">GACTableConstraint&lt; VarArray &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_leq_constraint.html">LeqConstraint&lt; VarRef1, VarRef2, Offset &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_less_equal_sum_constraint.html">LessEqualSumConstraint&lt; VarArray, VarSum, is_reversed &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_lex_leq_constraint.html">LexLeqConstraint&lt; VarArray1, VarArray2, Less &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_light_less_equal_sum_constraint.html">LightLessEqualSumConstraint&lt; VarRef, size, VarSum, is_reversed &gt;</a></td><td class="indexvalue">V1 + ... Vn &lt;= X </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_literal_specific_lists.html">LiteralSpecificLists</a></td><td class="indexvalue">The first GACtable implementation </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_literal_sum_constraint_dynamic.html">LiteralSumConstraintDynamic&lt; VarArray, ValueArray, VarSum &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_mem_block_cache.html">MemBlockCache</a></td><td class="indexvalue">Singleton type which tracks all occurrences of <a class="el" href="class_new_memory_block.html">NewMemoryBlock</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_memory.html">Memory</a></td><td class="indexvalue">Encapsulates both the backtrackable and nonbacktrackable memory of a CSP instance </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_min_constraint.html">MinConstraint&lt; VarArray, MinVarRef &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_mod_constraint.html">ModConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a></td><td class="indexvalue">Var1 % var2 = var3 </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_moveable_array.html">MoveableArray&lt; T &gt;</a></td><td class="indexvalue">Provides a wrapper around <a class="el" href="class_moveable_pointer.html">MoveablePointer</a> which makes an <a class="el" href="structarray.html" title="struct array [6.2.2]. NB: Requires complete type _Tp.">array</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_moveable_pointer.html">MoveablePointer</a></td><td class="indexvalue">Class which represents a moveable pointer </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_neq_constraint.html">NeqConstraint&lt; VarArray &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_new_memory_block.html">NewMemoryBlock</a></td><td class="indexvalue">Looks after all <a class="el" href="class_moveable_pointer.html">MoveablePointer</a> to a block of memory, and also the memory itself </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_not_mod_constraint.html">NotModConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_not_occurrence_equal_constraint.html">NotOccurrenceEqualConstraint&lt; VarArray, Val, ValCount &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_parent_constraint.html">ParentConstraint</a></td><td class="indexvalue">Constraint from which other constraints can be inherited. Extends dynamicconstraint to allow children to be dynamic </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_pow_constraint.html">PowConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a></td><td class="indexvalue">Var1 ^ var2 = var3 </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_product_constraint.html">ProductConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a></td><td class="indexvalue">Var1 * var2 = var3 </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_reified_equal_constraint.html">ReifiedEqualConstraint&lt; EqualVarRef1, EqualVarRef2, BoolVarRef &gt;</a></td><td class="indexvalue">(var1 = var2) = var3 </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_reversible.html">Reversible&lt; Type &gt;</a></td><td class="indexvalue">Provides a wrapper around a single backtrackable value </td></tr>
  <tr><td class="indexkey"><a class="el" href="structruntime__val.html">runtime_val</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_search_options.html">SearchOptions</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_trigger.html">Trigger</a></td><td class="indexvalue">The classes which are used to build the queue </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_trigger_creator.html">TriggerCreator&lt; VarRef &gt;</a></td><td class="indexvalue">Concrete <a class="el" href="class_trigger.html" title="The classes which are used to build the queue.">Trigger</a> Creators. Allows a trigger to be passed around before being imposed. This is here so reification works </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_trigger_range.html">TriggerRange</a></td><td class="indexvalue">Container for a range of triggers </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_prob_spec_1_1_var_container.html">ProbSpec::VarContainer</a></td><td class="indexvalue">Contains all the variables in a CSP instance </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_var_not.html">VarNot&lt; VarRef &gt;</a></td><td class="indexvalue">Nots a variable reference </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_vec_count_dynamic.html">VecCountDynamic&lt; VarArray1, VarArray2, Operator, is_reversed &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_vec_neq_dynamic.html">VecNeqDynamic&lt; VarArray1, VarArray2, Operator &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_watch_in_range_constraint.html">WatchInRangeConstraint&lt; Var &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_watch_in_set_constraint.html">WatchInSetConstraint&lt; Var &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_watch_less_constraint.html">WatchLessConstraint&lt; Var1, Var2, Negated &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_watch_literal_constraint.html">WatchLiteralConstraint&lt; Var &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_watch_not_in_range_constraint.html">WatchNotInRangeConstraint&lt; Var &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_watch_not_in_set_constraint.html">WatchNotInSetConstraint&lt; Var &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_watch_not_literal_constraint.html">WatchNotLiteralConstraint&lt; Var &gt;</a></td><td class="indexvalue"></td></tr>
</table>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Apr 12 22:47:11 2009 for Minion by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
