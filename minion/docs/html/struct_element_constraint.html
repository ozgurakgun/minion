<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Minion: ElementConstraint&lt; VarArray, IndexRef, VarRef &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ElementConstraint&lt; VarArray, IndexRef, VarRef &gt; Struct Template Reference</h1><!-- doxytag: class="ElementConstraint" --><!-- doxytag: inherits="AbstractConstraint" --><code>#include &lt;<a class="el" href="constraint__element_8h-source.html">constraint_element.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for ElementConstraint&lt; VarArray, IndexRef, VarRef &gt;:</div>
<div class="dynsection">
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for ElementConstraint&lt; VarArray, IndexRef, VarRef &gt;:</div>
<div class="dynsection">
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="struct_element_constraint-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="054b4e8ba97b147369afef24ae1a9d99"></a><!-- doxytag: member="ElementConstraint::constraint_name" ref="054b4e8ba97b147369afef24ae1a9d99" args="()" -->
virtual string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_element_constraint.html#054b4e8ba97b147369afef24ae1a9d99">constraint_name</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method to get constraint name for debugging. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b2073afc215ba88ba0973c0b0c2098ba"></a><!-- doxytag: member="ElementConstraint::ElementConstraint" ref="b2073afc215ba88ba0973c0b0c2098ba" args="(StateObj *_stateObj, const VarArray &amp;_var_array, const IndexRef &amp;_index_ref, const VarRef &amp;_result_var)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>ElementConstraint</b> (StateObj *_stateObj, const VarArray &amp;_var_array, const IndexRef &amp;_index_ref, const VarRef &amp;_result_var)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual triggerCollection&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_element_constraint.html#55945feda9bafe07939dd6b8e17cb0b1">setup_internal</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets all the triggers a constraint wants to set up.  <a href="#55945feda9bafe07939dd6b8e17cb0b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_element_constraint.html#067d9da6012acd3dcea4bf55f375aa51">propagate</a> (int prop_val, <a class="el" href="class_domain_delta.html">DomainDelta</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterative propagation function.  <a href="#067d9da6012acd3dcea4bf55f375aa51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_element_constraint.html#56eb6cceef8a39608e5d44798f8c88fa">full_propagate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a full round of propagation and sets up any data needs by <a class="el" href="struct_element_constraint.html#067d9da6012acd3dcea4bf55f375aa51" title="Iterative propagation function.">propagate()</a>.  <a href="#56eb6cceef8a39608e5d44798f8c88fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_element_constraint.html#f8be91d72620314afae7f0c3aa6f1f6a">check_assignment</a> (DomainInt *v, int v_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if an assignment is satisfied.  <a href="#f8be91d72620314afae7f0c3aa6f1f6a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e1ef53d066ef98903ad615a04541d194"></a><!-- doxytag: member="ElementConstraint::get_vars" ref="e1ef53d066ef98903ad615a04541d194" args="()" -->
virtual vector&lt; <a class="el" href="class_any_var_ref.html">AnyVarRef</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_vars</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_element_constraint.html#eaf04b3c36de4f4a069f350d7e7b6143">get_satisfying_assignment</a> (box&lt; pair&lt; int, DomainInt &gt; &gt; &amp;assignment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks for a valid partial assignment to a constraint.  <a href="#eaf04b3c36de4f4a069f350d7e7b6143"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_abstract_constraint.html">AbstractConstraint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_element_constraint.html#8b94c768d1d857b66b008c6d197d6627">reverse_constraint</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the reverse of the current constraint.  <a href="#8b94c768d1d857b66b008c6d197d6627"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="714b2c45346904540ba9eb917ebf3525"></a><!-- doxytag: member="ElementConstraint::var_array" ref="714b2c45346904540ba9eb917ebf3525" args="" -->
VarArray&nbsp;</td><td class="memItemRight" valign="bottom"><b>var_array</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d1333909c50fbd6e102cbae93c5c8643"></a><!-- doxytag: member="ElementConstraint::index_ref" ref="d1333909c50fbd6e102cbae93c5c8643" args="" -->
IndexRef&nbsp;</td><td class="memItemRight" valign="bottom"><b>index_ref</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3520d0dfd9fdc18996fff7432cd614b9"></a><!-- doxytag: member="ElementConstraint::result_var" ref="3520d0dfd9fdc18996fff7432cd614b9" args="" -->
VarRef&nbsp;</td><td class="memItemRight" valign="bottom"><b>result_var</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename VarArray, typename IndexRef, typename VarRef&gt;<br>
 struct ElementConstraint&lt; VarArray, IndexRef, VarRef &gt;</h3>

constraints;element_one Description The constraint element one is identical to element, except that the vector is indexed from 1 rather than from 0.  constraints;element_one References See<p>
help constraints element<p>
for details of the element constraint which is almost identical to this one.  constraints;element Description The constraint<p>
element(vec, i, e)<p>
specifies that, in any solution, vec[i] = e and i is in the range [0 .. |vec|-1].  constraints;element Notes<p>
Warning: This constraint is not confluent. Depending on the order the propagators are called in Minion, the number of search nodes may vary when using element. To avoid this problem, use watchelement instead. More details below.<p>
The level of propagation enforced by this constraint is not named, however it works as follows. For constraint vec[i]=e:<p>
<ul>
<li>After i is assigned, ensures that min(vec[i]) = min(e) and max(vec[i]) = max(e).</li></ul>
<p>
<ul>
<li>When e is assigned, removes idx from the domain of i whenever e is not an element of the domain of vec[idx].</li></ul>
<p>
<ul>
<li>When m[idx] is assigned, removes idx from i when m[idx] is not in the domain of e.</li></ul>
<p>
This level of consistency is designed to avoid the propagator having to scan through vec, except when e is assigned. It does a quantity of cheap propagation and may work well in practise on certain problems.<p>
Element is not confluent, which may cause the number of search nodes to vary depending on the order in which constraints are listed in the input file, or the order they are called in Minion. For example, the following input causes Minion to search 41 nodes.<p>
MINION 3 VARIABLES** DISCRETE x[5] {1..5} CONSTRAINTS** element([x[0],x[1],x[2]], x[3], x[4]) alldiff([x]) EOF**<p>
However if the two constraints are swapped over, Minion explores 29 nodes. As a rule of thumb, to get a lower node count, move element constraints to the end of the list.  constraints;element References See the entry<p>
constraints watchelement<p>
for details of an identical constraint that enforces generalised arc consistency. 
<p>Definition at line <a class="el" href="constraint__element_8h-source.html#l00105">105</a> of file <a class="el" href="constraint__element_8h-source.html">constraint_element.h</a>.</p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="55945feda9bafe07939dd6b8e17cb0b1"></a><!-- doxytag: member="ElementConstraint::setup_internal" ref="55945feda9bafe07939dd6b8e17cb0b1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VarArray, typename IndexRef, typename VarRef&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual triggerCollection <a class="el" href="struct_element_constraint.html">ElementConstraint</a>&lt; VarArray, IndexRef, VarRef &gt;::setup_internal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets all the triggers a constraint wants to set up. 
<p>
This function shouldn't do any propagation. That is full_propagate's job. 
<p>Reimplemented from <a class="el" href="class_abstract_constraint.html#a587ceba24e1386e5eb87df9cdabe7c9">AbstractConstraint</a>.</p>

<p>Definition at line <a class="el" href="constraint__element_8h-source.html#l00117">117</a> of file <a class="el" href="constraint__element_8h-source.html">constraint_element.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="067d9da6012acd3dcea4bf55f375aa51"></a><!-- doxytag: member="ElementConstraint::propagate" ref="067d9da6012acd3dcea4bf55f375aa51" args="(int prop_val, DomainDelta)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VarArray, typename IndexRef, typename VarRef&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="struct_element_constraint.html">ElementConstraint</a>&lt; VarArray, IndexRef, VarRef &gt;::propagate           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_domain_delta.html">DomainDelta</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterative propagation function. 
<p>
Can assume full_propagate is always called at least once before propagate 
<p>Reimplemented from <a class="el" href="class_abstract_constraint.html#e0b55b6ff9215c78d05afe03c3bcfc51">AbstractConstraint</a>.</p>

<p>Definition at line <a class="el" href="constraint__element_8h-source.html#l00129">129</a> of file <a class="el" href="constraint__element_8h-source.html">constraint_element.h</a>.</p>

<p>References <a class="el" href="constraint__abstract_8h-source.html#l00061">AbstractConstraint::stateObj</a>.</p>

</div>
</div><p>
<a class="anchor" name="56eb6cceef8a39608e5d44798f8c88fa"></a><!-- doxytag: member="ElementConstraint::full_propagate" ref="56eb6cceef8a39608e5d44798f8c88fa" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VarArray, typename IndexRef, typename VarRef&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="struct_element_constraint.html">ElementConstraint</a>&lt; VarArray, IndexRef, VarRef &gt;::full_propagate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a full round of propagation and sets up any data needs by <a class="el" href="struct_element_constraint.html#067d9da6012acd3dcea4bf55f375aa51" title="Iterative propagation function.">propagate()</a>. 
<p>
This function can be called during search if the function is reified 
<p>Implements <a class="el" href="class_abstract_constraint.html#e7da3594511a334d35053e3c68a76e87">AbstractConstraint</a>.</p>

<p>Definition at line <a class="el" href="constraint__element_8h-source.html#l00190">190</a> of file <a class="el" href="constraint__element_8h-source.html">constraint_element.h</a>.</p>

<p>References <a class="el" href="constraint__abstract_8h-source.html#l00061">AbstractConstraint::stateObj</a>.</p>

</div>
</div><p>
<a class="anchor" name="f8be91d72620314afae7f0c3aa6f1f6a"></a><!-- doxytag: member="ElementConstraint::check_assignment" ref="f8be91d72620314afae7f0c3aa6f1f6a" args="(DomainInt *v, int v_size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VarArray, typename IndexRef, typename VarRef&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual BOOL <a class="el" href="struct_element_constraint.html">ElementConstraint</a>&lt; VarArray, IndexRef, VarRef &gt;::check_assignment           </td>
          <td>(</td>
          <td class="paramtype">DomainInt *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if an assignment is satisfied. 
<p>
This takes the variable order returned by, and is mainly only used by, get_table_constraint() 
<p>Implements <a class="el" href="class_abstract_constraint.html#e0f1648011903a59b830ce4585e2d2b2">AbstractConstraint</a>.</p>

<p>Definition at line <a class="el" href="constraint__element_8h-source.html#l00334">334</a> of file <a class="el" href="constraint__element_8h-source.html">constraint_element.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="eaf04b3c36de4f4a069f350d7e7b6143"></a><!-- doxytag: member="ElementConstraint::get_satisfying_assignment" ref="eaf04b3c36de4f4a069f350d7e7b6143" args="(box&lt; pair&lt; int, DomainInt &gt; &gt; &amp;assignment)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VarArray, typename IndexRef, typename VarRef&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="struct_element_constraint.html">ElementConstraint</a>&lt; VarArray, IndexRef, VarRef &gt;::get_satisfying_assignment           </td>
          <td>(</td>
          <td class="paramtype">box&lt; pair&lt; int, DomainInt &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>assignment</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks for a valid partial assignment to a constraint. 
<p>
The return value (in the box) is pairs of &lt;varnum, domain value&gt;, where varnum is in the same position as returned by get_vars. 
<p>Reimplemented from <a class="el" href="class_abstract_constraint.html#45b16763beb699121616ca939d7b8279">AbstractConstraint</a>.</p>

<p>Definition at line <a class="el" href="constraint__element_8h-source.html#l00353">353</a> of file <a class="el" href="constraint__element_8h-source.html">constraint_element.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8b94c768d1d857b66b008c6d197d6627"></a><!-- doxytag: member="ElementConstraint::reverse_constraint" ref="8b94c768d1d857b66b008c6d197d6627" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VarArray, typename IndexRef, typename VarRef&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_abstract_constraint.html">AbstractConstraint</a>* <a class="el" href="struct_element_constraint.html">ElementConstraint</a>&lt; VarArray, IndexRef, VarRef &gt;::reverse_constraint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the reverse of the current constraint. 
<p>
Used by rarification 
<p>Reimplemented from <a class="el" href="class_abstract_constraint.html#7d3bc6c554d81fd7abef354cfe28383c">AbstractConstraint</a>.</p>

<p>Definition at line <a class="el" href="constraint__element_8h-source.html#l00382">382</a> of file <a class="el" href="constraint__element_8h-source.html">constraint_element.h</a>.</p>

<p>References <a class="el" href="constraint__abstract_8h-source.html#l00061">AbstractConstraint::stateObj</a>.</p>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="constraint__element_8h-source.html">constraint_element.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Apr 12 22:47:12 2009 for Minion by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
