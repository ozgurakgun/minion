<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Minion: AbstractConstraint Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>AbstractConstraint Class Reference</h1><!-- doxytag: class="AbstractConstraint" -->Base type from which all constraints are derived.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="constraint__abstract_8h-source.html">constraint_abstract.h</a>&gt;</code>
<p>
Inherited by <a class="el" href="struct_abs_constraint.html">AbsConstraint&lt; AbsVarRef1, AbsVarRef2 &gt;</a>, <a class="el" href="struct_and_constraint.html">AndConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_bool_binary_s_a_t_constraint_dynamic.html">BoolBinarySATConstraintDynamic&lt; VarArray &gt;</a>, BoolLessSumConstraint&lt; VarArray, VarSum, VarToCount &gt;, <a class="el" href="struct_bool_less_sum_constraint_dynamic.html">BoolLessSumConstraintDynamic&lt; VarArray, VarSum, VarToCount, is_reversed &gt;</a>, BoolOrConstraintDynamic&lt; VarArray &gt;, BoolSATConstraintDynamic&lt; VarArray &gt;, BoolThreeSATConstraintDynamic&lt; VarArray &gt;, BoundsTableConstraint&lt; VarArray &gt;, CheckAssignConstraint&lt; VarArray, OriginalConstraint &gt;, CliqueConstraint&lt; VarArray &gt;, <a class="el" href="struct_constant_constraint.html">ConstantConstraint&lt; truth &gt;</a>, ConstantOccurrenceEqualConstraint&lt; VarArray, Val &gt;, <a class="el" href="struct_difference_constraint.html">DifferenceConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_div_constraint.html">DivConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, Dynamic_reify_true_old&lt; BoolVar &gt;, <a class="el" href="struct_element_constraint.html">ElementConstraint&lt; VarArray, IndexRef, VarRef &gt;</a>, <a class="el" href="struct_element_constraint_dynamic.html">ElementConstraintDynamic&lt; VarArray, Index, Result &gt;</a>, EqualConstraint&lt; EqualVarRef1, EqualVarRef2 &gt;, GacAlldiff&lt; VarArray &gt;, GACElementConstraint&lt; VarArray, IndexRef, VarRef &gt;, <a class="el" href="struct_g_a_c_table_constraint.html">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_g_a_c_table_constraint.html">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_g_a_c_table_constraint.html">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_g_a_c_table_constraint.html">GACTableConstraint&lt; VarArray &gt;</a>, GadgetConstraint&lt; VarArray &gt;, GCC&lt; VarArray1, VarArray2, Strongcards &gt;, GraphIsoConstraint&lt; VarArray &gt;, <a class="el" href="struct_leq_constraint.html">LeqConstraint&lt; VarRef1, VarRef2, Offset &gt;</a>, <a class="el" href="struct_less_equal_sum_constraint.html">LessEqualSumConstraint&lt; VarArray, VarSum, is_reversed &gt;</a>, <a class="el" href="struct_lex_leq_constraint.html">LexLeqConstraint&lt; VarArray1, VarArray2, Less &gt;</a>, <a class="el" href="struct_light_less_equal_sum_constraint.html">LightLessEqualSumConstraint&lt; VarRef, size, VarSum, is_reversed &gt;</a>, <a class="el" href="struct_literal_sum_constraint_dynamic.html">LiteralSumConstraintDynamic&lt; VarArray, ValueArray, VarSum &gt;</a>, <a class="el" href="struct_min_constraint.html">MinConstraint&lt; VarArray, MinVarRef &gt;</a>, <a class="el" href="struct_mod_constraint.html">ModConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_neq_constraint.html">NeqConstraint&lt; VarArray &gt;</a>, NeqConstraintBinary&lt; VarRef1, VarRef2 &gt;, NewTableConstraint&lt; VarArray, TableDataType, TableStateType &gt;, <a class="el" href="struct_not_mod_constraint.html">NotModConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_not_occurrence_equal_constraint.html">NotOccurrenceEqualConstraint&lt; VarArray, Val, ValCount &gt;</a>, OccurrenceEqualConstraint&lt; VarArray, Val, ValCount &gt;, <a class="el" href="class_parent_constraint.html">ParentConstraint</a>, <a class="el" href="struct_pow_constraint.html">PowConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_product_constraint.html">ProductConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_reified_equal_constraint.html">ReifiedEqualConstraint&lt; EqualVarRef1, EqualVarRef2, BoolVarRef &gt;</a>, reify_true_old&lt; BoolVar &gt;, SumEqConstraintDynamic&lt; VarRef1, VarRef2, VarRef3 &gt;, TableConstraint&lt; VarArray &gt;, UnaryEqualConstraint&lt; VarRef, Offset &gt;, UnaryNeqConstraint&lt; VarRef, Offset &gt;, <a class="el" href="struct_vec_count_dynamic.html">VecCountDynamic&lt; VarArray1, VarArray2, Operator, is_reversed &gt;</a>, <a class="el" href="struct_vec_neq_dynamic.html">VecNeqDynamic&lt; VarArray1, VarArray2, Operator &gt;</a>, <a class="el" href="struct_watch_in_range_constraint.html">WatchInRangeConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_in_set_constraint.html">WatchInSetConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_less_constraint.html">WatchLessConstraint&lt; Var1, Var2, Negated &gt;</a>, <a class="el" href="struct_watch_literal_constraint.html">WatchLiteralConstraint&lt; Var &gt;</a>, WatchNeqConstraint&lt; Var1, Var2 &gt;, <a class="el" href="struct_watch_not_in_range_constraint.html">WatchNotInRangeConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_not_in_set_constraint.html">WatchNotInSetConstraint&lt; Var &gt;</a>, WatchNotLiteralBoolConstraint, and <a class="el" href="struct_watch_not_literal_constraint.html">WatchNotLiteralConstraint&lt; Var &gt;</a>.
<p>
<div class="dynheader">
Collaboration diagram for AbstractConstraint:</div>
<div class="dynsection">
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="class_abstract_constraint-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="471743522a004357a9c4501a1a45b112"></a><!-- doxytag: member="AbstractConstraint::dynamic_trigger_start" ref="471743522a004357a9c4501a1a45b112" args="()" -->
<a class="el" href="class_dynamic_trigger.html">DynamicTrigger</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_constraint.html#471743522a004357a9c4501a1a45b112">dynamic_trigger_start</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a point to the first dynamic trigger of the constraint. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_constraint.html#9bb2ec6e576875a3b129d4523ba37166">dynamic_trigger_count</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_constraint.html#ca51110dd89727f69a7236f74d8c464a">dynamic_trigger_count_with_children</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual triggerCollection&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_constraint.html#a587ceba24e1386e5eb87df9cdabe7c9">setup_internal</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets all the triggers a constraint wants to set up.  <a href="#a587ceba24e1386e5eb87df9cdabe7c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_constraint.html#8628fdd06ba1cba4ce6005c0404e2256">propagate</a> (<a class="el" href="class_dynamic_trigger.html">DynamicTrigger</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterative propagation function.  <a href="#8628fdd06ba1cba4ce6005c0404e2256"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_constraint.html#e0b55b6ff9215c78d05afe03c3bcfc51">propagate</a> (int, <a class="el" href="class_domain_delta.html">DomainDelta</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterative propagation function.  <a href="#e0b55b6ff9215c78d05afe03c3bcfc51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_constraint.html#1483521bab6c40e88d3eac924b318745">full_check_unsat</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_constraint.html#a6517f8782ecbe5e313b349be19b1473">check_unsat</a> (int, <a class="el" href="class_domain_delta.html">DomainDelta</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_constraint.html#45b16763beb699121616ca939d7b8279">get_satisfying_assignment</a> (box&lt; pair&lt; int, DomainInt &gt; &gt; &amp;assignment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks for a valid partial assignment to a constraint.  <a href="#45b16763beb699121616ca939d7b8279"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_abstract_constraint.html">AbstractConstraint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_constraint.html#7d3bc6c554d81fd7abef354cfe28383c">reverse_constraint</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the reverse of the current constraint.  <a href="#7d3bc6c554d81fd7abef354cfe28383c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2914c8bae8497e3856083d1e4db002c8"></a><!-- doxytag: member="AbstractConstraint::AbstractConstraint" ref="2914c8bae8497e3856083d1e4db002c8" args="(StateObj *_stateObj)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>AbstractConstraint</b> (StateObj *_stateObj)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="75f3857df083dd0fdba78e70346676f8"></a><!-- doxytag: member="AbstractConstraint::constraint_name" ref="75f3857df083dd0fdba78e70346676f8" args="()=0" -->
virtual string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_constraint.html#75f3857df083dd0fdba78e70346676f8">constraint_name</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method to get constraint name for debugging. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_constraint.html#e7da3594511a334d35053e3c68a76e87">full_propagate</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a full round of propagation and sets up any data needs by <a class="el" href="class_abstract_constraint.html#8628fdd06ba1cba4ce6005c0404e2256" title="Iterative propagation function.">propagate()</a>.  <a href="#e7da3594511a334d35053e3c68a76e87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dee0043dc538aead6d6dabf07530f814"></a><!-- doxytag: member="AbstractConstraint::get_vars" ref="dee0043dc538aead6d6dabf07530f814" args="()=0" -->
virtual vector&lt; <a class="el" href="class_any_var_ref.html">AnyVarRef</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_vars</b> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="470c8839086ed88c88c009d408cc81c1"></a><!-- doxytag: member="AbstractConstraint::get_vars_singleton" ref="470c8839086ed88c88c009d408cc81c1" args="()" -->
vector&lt; <a class="el" href="class_any_var_ref.html">AnyVarRef</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_vars_singleton</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c80915817ee45b47e92da0a9c7b67522"></a><!-- doxytag: member="AbstractConstraint::getTrigWeight" ref="c80915817ee45b47e92da0a9c7b67522" args="()" -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><b>getTrigWeight</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_constraint.html#f818b650a0c4f3f50c6ab2cad5817ecf">special_check</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e130641e159e7bc810825669321a8c3e"></a><!-- doxytag: member="AbstractConstraint::special_unlock" ref="e130641e159e7bc810825669321a8c3e" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>special_unlock</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_constraint.html#e0f1648011903a59b830ce4585e2d2b2">check_assignment</a> (DomainInt *v, int v_size)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if an assignment is satisfied.  <a href="#e0f1648011903a59b830ce4585e2d2b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="47f7e3f17a56c269e9aa4066e729e221"></a><!-- doxytag: member="AbstractConstraint::setup_dynamic_triggers" ref="47f7e3f17a56c269e9aa4066e729e221" args="(MemOffset DynamicTriggerPointer)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setup_dynamic_triggers</b> (<a class="el" href="class_moveable_pointer.html">MemOffset</a> DynamicTriggerPointer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d154e710f46e1817d9268e6e60116001"></a><!-- doxytag: member="AbstractConstraint::setup_internal_gather_triggers" ref="d154e710f46e1817d9268e6e60116001" args="()" -->
virtual triggerCollection&nbsp;</td><td class="memItemRight" valign="bottom"><b>setup_internal_gather_triggers</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_constraint.html#587e70c5fc0270491535f77c9950b6d1">setup</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ab9c3efb89e936667d167bd724371a41"></a><!-- doxytag: member="AbstractConstraint::full_propagate_done" ref="ab9c3efb89e936667d167bd724371a41" args="" -->
BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><b>full_propagate_done</b></td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3061f9e8c50fd2b054d295263ffdc4e8"></a><!-- doxytag: member="AbstractConstraint::stateObj" ref="3061f9e8c50fd2b054d295263ffdc4e8" args="" -->
StateObj *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_constraint.html#3061f9e8c50fd2b054d295263ffdc4e8">stateObj</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Private members of the base class. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="411c33a87a5473baf06c894d04c29aed"></a><!-- doxytag: member="AbstractConstraint::_DynamicTriggerCache" ref="411c33a87a5473baf06c894d04c29aed" args="" -->
<a class="el" href="class_moveable_pointer.html">MemOffset</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>_DynamicTriggerCache</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c8fbffe1f6a695e21d3409afaac2746b"></a><!-- doxytag: member="AbstractConstraint::singleton_vars" ref="c8fbffe1f6a695e21d3409afaac2746b" args="" -->
vector&lt; <a class="el" href="class_any_var_ref.html">AnyVarRef</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>singleton_vars</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Base type from which all constraints are derived. 
<p>Definition at line <a class="el" href="constraint__abstract_8h-source.html#l00056">56</a> of file <a class="el" href="constraint__abstract_8h-source.html">constraint_abstract.h</a>.</p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="9bb2ec6e576875a3b129d4523ba37166"></a><!-- doxytag: member="AbstractConstraint::dynamic_trigger_count" ref="9bb2ec6e576875a3b129d4523ba37166" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int AbstractConstraint::dynamic_trigger_count           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines the number of dynamic triggers the constraint wants. Must be implemented by any constraint. 
<p>Reimplemented in <a class="el" href="struct_g_a_c_table_constraint.html#be4901d10750d8a95de6feab172fb3e4">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_g_a_c_table_constraint.html#be4901d10750d8a95de6feab172fb3e4">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_g_a_c_table_constraint.html#be4901d10750d8a95de6feab172fb3e4">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_g_a_c_table_constraint.html#be4901d10750d8a95de6feab172fb3e4">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_not_occurrence_equal_constraint.html#cdd41ccd87e47d8a9061b555a5aaa785">NotOccurrenceEqualConstraint&lt; VarArray, Val, ValCount &gt;</a>, <a class="el" href="struct_bool_binary_s_a_t_constraint_dynamic.html#918d67c1e7a928266191d136f3388e16">BoolBinarySATConstraintDynamic&lt; VarArray &gt;</a>, <a class="el" href="struct_element_constraint_dynamic.html#b33434629fcfd5174ac3cd67770fdee9">ElementConstraintDynamic&lt; VarArray, Index, Result &gt;</a>, <a class="el" href="struct_watch_less_constraint.html#91d8201dc308a4c4887aaf09bf9f0750">WatchLessConstraint&lt; Var1, Var2, Negated &gt;</a>, <a class="el" href="struct_literal_sum_constraint_dynamic.html#d4328c88419e7c417fe3135262010201">LiteralSumConstraintDynamic&lt; VarArray, ValueArray, VarSum &gt;</a>, <a class="el" href="struct_bool_less_sum_constraint_dynamic.html#72cbb50edd60acaed9b6e15044159a71">BoolLessSumConstraintDynamic&lt; VarArray, VarSum, VarToCount, is_reversed &gt;</a>, <a class="el" href="struct_vec_count_dynamic.html#8a7361ee6930ad050262413e0b358328">VecCountDynamic&lt; VarArray1, VarArray2, Operator, is_reversed &gt;</a>, <a class="el" href="struct_vec_neq_dynamic.html#d26d66a484c0405993db82ecb8b34616">VecNeqDynamic&lt; VarArray1, VarArray2, Operator &gt;</a>, <a class="el" href="struct_watch_in_range_constraint.html#9ee27f8d1ad54b0c7391edd758ab155a">WatchInRangeConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_in_set_constraint.html#d96de435dd38b390e62a818dbbf9d76f">WatchInSetConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_literal_constraint.html#8234860d7b037fcfa8c70539303f913d">WatchLiteralConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_not_in_range_constraint.html#39ff3feffb990d8077189d8c08ee3c72">WatchNotInRangeConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_not_in_set_constraint.html#71a3bbb3dd0f443219bf327b0b2511f6">WatchNotInSetConstraint&lt; Var &gt;</a>, and <a class="el" href="struct_watch_not_literal_constraint.html#af5dcbef3dd7c3d30f4a66c14ce13c97">WatchNotLiteralConstraint&lt; Var &gt;</a>.</p>

<p>Definition at line <a class="el" href="constraint__abstract_8h-source.html#l00080">80</a> of file <a class="el" href="constraint__abstract_8h-source.html">constraint_abstract.h</a>.</p>

<p>Referenced by <a class="el" href="constraint__abstract_8h-source.html#l00295">ParentConstraint::dynamic_trigger_count_with_children()</a>, <a class="el" href="constraint__abstract_8h-source.html#l00085">dynamic_trigger_count_with_children()</a>, <a class="el" href="constraint__abstract_8h-source.html#l00334">ParentConstraint::setup()</a>, and <a class="el" href="constraint__abstract_8h-source.html#l00208">setup()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ca51110dd89727f69a7236f74d8c464a"></a><!-- doxytag: member="AbstractConstraint::dynamic_trigger_count_with_children" ref="ca51110dd89727f69a7236f74d8c464a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int AbstractConstraint::dynamic_trigger_count_with_children           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of dynamic triggers for this constraint, and all the children of this constraint. Only differs from the above for things like 'reify', 'reifyimply' and 'or'. 
<p>Reimplemented in <a class="el" href="class_parent_constraint.html#dc9026e40d1dac868034185211d2b200">ParentConstraint</a>.</p>

<p>Definition at line <a class="el" href="constraint__abstract_8h-source.html#l00085">85</a> of file <a class="el" href="constraint__abstract_8h-source.html">constraint_abstract.h</a>.</p>

<p>References <a class="el" href="constraint__abstract_8h-source.html#l00080">dynamic_trigger_count()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="a587ceba24e1386e5eb87df9cdabe7c9"></a><!-- doxytag: member="AbstractConstraint::setup_internal" ref="a587ceba24e1386e5eb87df9cdabe7c9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual triggerCollection AbstractConstraint::setup_internal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets all the triggers a constraint wants to set up. 
<p>
This function shouldn't do any propagation. That is full_propagate's job. 
<p>Reimplemented in <a class="el" href="struct_abs_constraint.html#14b89605f9c4936d60a2455b7ac28636">AbsConstraint&lt; AbsVarRef1, AbsVarRef2 &gt;</a>, <a class="el" href="struct_and_constraint.html#4b7c695fa8b793197c7eddce6049b4e1">AndConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_constant_constraint.html#bf2608e2da68ce5f003e0ca14cd273ea">ConstantConstraint&lt; truth &gt;</a>, <a class="el" href="struct_difference_constraint.html#58269a7aefdbcee92791db530a32cc97">DifferenceConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_div_constraint.html#7481ed7612fe57bb360c1489f6b08219">DivConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_element_constraint.html#55945feda9bafe07939dd6b8e17cb0b1">ElementConstraint&lt; VarArray, IndexRef, VarRef &gt;</a>, <a class="el" href="struct_reified_equal_constraint.html#c625d52ea8170d58110792b89dd00f0e">ReifiedEqualConstraint&lt; EqualVarRef1, EqualVarRef2, BoolVarRef &gt;</a>, <a class="el" href="struct_leq_constraint.html#cc3cb0ee600186d2a987e118d9123b54">LeqConstraint&lt; VarRef1, VarRef2, Offset &gt;</a>, <a class="el" href="struct_lex_leq_constraint.html#63c3ae2224f25d80e97533eda202201a">LexLeqConstraint&lt; VarArray1, VarArray2, Less &gt;</a>, <a class="el" href="struct_min_constraint.html#325b5b01a1b81c7660a12552abbaed86">MinConstraint&lt; VarArray, MinVarRef &gt;</a>, <a class="el" href="struct_not_mod_constraint.html#a936a2ad8c12c6cf7227d7dae9bdc2c2">NotModConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_mod_constraint.html#9ef9df2b935b06f3440c8218e0ba2baf">ModConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_neq_constraint.html#e837266a192a819870045e73130b00f7">NeqConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_not_occurrence_equal_constraint.html#195dbaa7f2c1316d8fe18d73a293d061">NotOccurrenceEqualConstraint&lt; VarArray, Val, ValCount &gt;</a>, <a class="el" href="struct_pow_constraint.html#96168c33ba6373c7c2fc673f07161fbc">PowConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_product_constraint.html#e5783c8b020ad1cfd19220aa47ecc7c8">ProductConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_less_equal_sum_constraint.html#b6f386f2a719f5400c17af2817e90a84">LessEqualSumConstraint&lt; VarArray, VarSum, is_reversed &gt;</a>, and <a class="el" href="struct_light_less_equal_sum_constraint.html#fa97907943317689692e8138d0d4f57b">LightLessEqualSumConstraint&lt; VarRef, size, VarSum, is_reversed &gt;</a>.</p>

<p>Definition at line <a class="el" href="constraint__abstract_8h-source.html#l00090">90</a> of file <a class="el" href="constraint__abstract_8h-source.html">constraint_abstract.h</a>.</p>

<p>Referenced by <a class="el" href="constraint__abstract_8h-source.html#l00253">ParentConstraint::setup_internal_gather_triggers()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8628fdd06ba1cba4ce6005c0404e2256"></a><!-- doxytag: member="AbstractConstraint::propagate" ref="8628fdd06ba1cba4ce6005c0404e2256" args="(DynamicTrigger *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AbstractConstraint::propagate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_dynamic_trigger.html">DynamicTrigger</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterative propagation function. 
<p>
Can assume full_propagate is always called at least once before propagate 
<p>Reimplemented in <a class="el" href="struct_g_a_c_table_constraint.html#95088d8348e3e4c2527b98e281ecc999">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_g_a_c_table_constraint.html#95088d8348e3e4c2527b98e281ecc999">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_g_a_c_table_constraint.html#95088d8348e3e4c2527b98e281ecc999">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_g_a_c_table_constraint.html#95088d8348e3e4c2527b98e281ecc999">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_not_occurrence_equal_constraint.html#a357ad4912a653c3fd60f12b77ae4200">NotOccurrenceEqualConstraint&lt; VarArray, Val, ValCount &gt;</a>, <a class="el" href="struct_bool_binary_s_a_t_constraint_dynamic.html#45cbf3547fc1d770eda722164b053584">BoolBinarySATConstraintDynamic&lt; VarArray &gt;</a>, <a class="el" href="struct_element_constraint_dynamic.html#f220e48afa52cefe2c5b8f6c19eed45d">ElementConstraintDynamic&lt; VarArray, Index, Result &gt;</a>, <a class="el" href="struct_watch_less_constraint.html#c704c82452a61eed348b118979a0f280">WatchLessConstraint&lt; Var1, Var2, Negated &gt;</a>, <a class="el" href="struct_literal_sum_constraint_dynamic.html#a3317014aba820b25f16f9318d87d15f">LiteralSumConstraintDynamic&lt; VarArray, ValueArray, VarSum &gt;</a>, <a class="el" href="struct_bool_less_sum_constraint_dynamic.html#eeec7eaab8344b62385cdc9d7f003a00">BoolLessSumConstraintDynamic&lt; VarArray, VarSum, VarToCount, is_reversed &gt;</a>, <a class="el" href="struct_vec_count_dynamic.html#f0361bd275e5f7e5321676fcbce8607c">VecCountDynamic&lt; VarArray1, VarArray2, Operator, is_reversed &gt;</a>, <a class="el" href="struct_vec_neq_dynamic.html#3b7733fafc43aab150340e9847f8f6bc">VecNeqDynamic&lt; VarArray1, VarArray2, Operator &gt;</a>, <a class="el" href="struct_watch_in_range_constraint.html#7ce24ecd6daf13a764bf74d8d1a44028">WatchInRangeConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_in_set_constraint.html#9874cb78d7da5f5f5035d93e7add6644">WatchInSetConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_literal_constraint.html#0637ab3b6470e9e1f89654b23c000ff1">WatchLiteralConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_not_in_range_constraint.html#02ffa991f439223ea0497171cae2a32d">WatchNotInRangeConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_not_in_set_constraint.html#a4a11d7faee0fdb941d02f73f0c6bcf7">WatchNotInSetConstraint&lt; Var &gt;</a>, and <a class="el" href="struct_watch_not_literal_constraint.html#d93631f2ff426d3463ec291a9e13a370">WatchNotLiteralConstraint&lt; Var &gt;</a>.</p>

<p>Definition at line <a class="el" href="constraint__abstract_8h-source.html#l00095">95</a> of file <a class="el" href="constraint__abstract_8h-source.html">constraint_abstract.h</a>.</p>

<p>References <a class="el" href="class_abstract_constraint.html#75f3857df083dd0fdba78e70346676f8">constraint_name()</a>.</p>

<p>Referenced by <a class="el" href="constraint__abstract_8hpp-source.html#l00033">DynamicTrigger::propagate()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="e0b55b6ff9215c78d05afe03c3bcfc51"></a><!-- doxytag: member="AbstractConstraint::propagate" ref="e0b55b6ff9215c78d05afe03c3bcfc51" args="(int, DomainDelta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AbstractConstraint::propagate           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_domain_delta.html">DomainDelta</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterative propagation function. 
<p>
Can assume full_propagate is always called at least once before propagate 
<p>Reimplemented in <a class="el" href="struct_abs_constraint.html#d3bf2d2bbd74340bbf6e47e4daadc3da">AbsConstraint&lt; AbsVarRef1, AbsVarRef2 &gt;</a>, <a class="el" href="struct_and_constraint.html#4e088cf50d02107ebe115de98803df75">AndConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_constant_constraint.html#c8d8bf0e1bfe954fbf244be9221729e0">ConstantConstraint&lt; truth &gt;</a>, <a class="el" href="struct_difference_constraint.html#f97bd35c949f5c7bee702580563bc9dc">DifferenceConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_div_constraint.html#290fdb17f4221b870b5c65c896b17ed2">DivConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_element_constraint.html#067d9da6012acd3dcea4bf55f375aa51">ElementConstraint&lt; VarArray, IndexRef, VarRef &gt;</a>, <a class="el" href="struct_reified_equal_constraint.html#c83ed62a90f8a491d6b8d113c47a97b2">ReifiedEqualConstraint&lt; EqualVarRef1, EqualVarRef2, BoolVarRef &gt;</a>, <a class="el" href="struct_leq_constraint.html#ff62060687f2637411ba1923dc2055f4">LeqConstraint&lt; VarRef1, VarRef2, Offset &gt;</a>, <a class="el" href="struct_lex_leq_constraint.html#cc59ae0f89b7bcd1ec777203a822666e">LexLeqConstraint&lt; VarArray1, VarArray2, Less &gt;</a>, <a class="el" href="struct_min_constraint.html#e803594e3942c99e2235c45ec672fa83">MinConstraint&lt; VarArray, MinVarRef &gt;</a>, <a class="el" href="struct_not_mod_constraint.html#cc1a30ff2d25c8cc73e719c4c4036085">NotModConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_mod_constraint.html#f883d4a2f2cab283af512bd06ac438c2">ModConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_neq_constraint.html#0dab0802dcd58117a7fbe513f179b564">NeqConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_not_occurrence_equal_constraint.html#3db31bb0fd284b2b7bded1ac10f6939b">NotOccurrenceEqualConstraint&lt; VarArray, Val, ValCount &gt;</a>, <a class="el" href="struct_pow_constraint.html#ff49fcf30b07232d8c66aa7e22e45fd8">PowConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_product_constraint.html#45b23e38e9263b08cf233b72fcd5da3c">ProductConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_less_equal_sum_constraint.html#31382de3e3392dc319c66f6e4201f592">LessEqualSumConstraint&lt; VarArray, VarSum, is_reversed &gt;</a>, and <a class="el" href="struct_light_less_equal_sum_constraint.html#59eaed7c5799a4aaa8ad943f6e22d7ac">LightLessEqualSumConstraint&lt; VarRef, size, VarSum, is_reversed &gt;</a>.</p>

<p>Definition at line <a class="el" href="constraint__abstract_8h-source.html#l00100">100</a> of file <a class="el" href="constraint__abstract_8h-source.html">constraint_abstract.h</a>.</p>

<p>References <a class="el" href="class_abstract_constraint.html#75f3857df083dd0fdba78e70346676f8">constraint_name()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="1483521bab6c40e88d3eac924b318745"></a><!-- doxytag: member="AbstractConstraint::full_check_unsat" ref="1483521bab6c40e88d3eac924b318745" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual BOOL AbstractConstraint::full_check_unsat           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if a constraint cannot be satisfied, and sets up any data structures for future incremental checks. Returns TRUE if constraint cannot be satisfied. This function is used by rarification 
<p>Reimplemented in <a class="el" href="struct_leq_constraint.html#8bf9fb4bd10a84c1b6d1b5abdb393041">LeqConstraint&lt; VarRef1, VarRef2, Offset &gt;</a>, <a class="el" href="struct_lex_leq_constraint.html#59088347621331659b900881648c58f7">LexLeqConstraint&lt; VarArray1, VarArray2, Less &gt;</a>, <a class="el" href="struct_neq_constraint.html#33aa882dc7ea355f83571905e3818c94">NeqConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_less_equal_sum_constraint.html#bab02f11f899883dcbc7524c5f9089fd">LessEqualSumConstraint&lt; VarArray, VarSum, is_reversed &gt;</a>, and <a class="el" href="struct_light_less_equal_sum_constraint.html#5c562c96411a4f7f3c04f0ec3be24b4a">LightLessEqualSumConstraint&lt; VarRef, size, VarSum, is_reversed &gt;</a>.</p>

<p>Definition at line <a class="el" href="constraint__abstract_8h-source.html#l00106">106</a> of file <a class="el" href="constraint__abstract_8h-source.html">constraint_abstract.h</a>.</p>

<p>References <a class="el" href="class_abstract_constraint.html#75f3857df083dd0fdba78e70346676f8">constraint_name()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="a6517f8782ecbe5e313b349be19b1473"></a><!-- doxytag: member="AbstractConstraint::check_unsat" ref="a6517f8782ecbe5e313b349be19b1473" args="(int, DomainDelta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual BOOL AbstractConstraint::check_unsat           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_domain_delta.html">DomainDelta</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks incrementaly if constraint cannot be satisfied. Returns TRUE if constraint cannot be satisfied. This function should not be called unless check_unsat_full is called first. This is used by rarification 
<p>Reimplemented in <a class="el" href="struct_leq_constraint.html#ef7cf5e44cf0c085467f973d0b2d6429">LeqConstraint&lt; VarRef1, VarRef2, Offset &gt;</a>, <a class="el" href="struct_lex_leq_constraint.html#3fa315bd82da36d75bb696671014c7ea">LexLeqConstraint&lt; VarArray1, VarArray2, Less &gt;</a>, <a class="el" href="struct_neq_constraint.html#100567e2f5434300f23c842c5d767d6f">NeqConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_less_equal_sum_constraint.html#0ce05a21435a0b2d5329534e9294ef17">LessEqualSumConstraint&lt; VarArray, VarSum, is_reversed &gt;</a>, and <a class="el" href="struct_light_less_equal_sum_constraint.html#129a16e0d56ddd7de7ea5835945b9898">LightLessEqualSumConstraint&lt; VarRef, size, VarSum, is_reversed &gt;</a>.</p>

<p>Definition at line <a class="el" href="constraint__abstract_8h-source.html#l00115">115</a> of file <a class="el" href="constraint__abstract_8h-source.html">constraint_abstract.h</a>.</p>

<p>References <a class="el" href="class_abstract_constraint.html#75f3857df083dd0fdba78e70346676f8">constraint_name()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="45b16763beb699121616ca939d7b8279"></a><!-- doxytag: member="AbstractConstraint::get_satisfying_assignment" ref="45b16763beb699121616ca939d7b8279" args="(box&lt; pair&lt; int, DomainInt &gt; &gt; &amp;assignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool AbstractConstraint::get_satisfying_assignment           </td>
          <td>(</td>
          <td class="paramtype">box&lt; pair&lt; int, DomainInt &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>assignment</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks for a valid partial assignment to a constraint. 
<p>
The return value (in the box) is pairs of &lt;varnum, domain value&gt;, where varnum is in the same position as returned by get_vars. 
<p>Reimplemented in <a class="el" href="struct_abs_constraint.html#c174bf312881a065ae43e5ebad8ed806">AbsConstraint&lt; AbsVarRef1, AbsVarRef2 &gt;</a>, <a class="el" href="struct_and_constraint.html#76b80e3efb79d149da68ac1a15786f42">AndConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_constant_constraint.html#36388e859d8398da5551c85e0df2f22d">ConstantConstraint&lt; truth &gt;</a>, <a class="el" href="struct_difference_constraint.html#062b8617fb5b96689968eb9976a0627b">DifferenceConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_div_constraint.html#a012319bc60b8d1800d0e443093555a7">DivConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_element_constraint.html#eaf04b3c36de4f4a069f350d7e7b6143">ElementConstraint&lt; VarArray, IndexRef, VarRef &gt;</a>, <a class="el" href="struct_leq_constraint.html#0b25e088c1d1e6082b977a34f9e12016">LeqConstraint&lt; VarRef1, VarRef2, Offset &gt;</a>, <a class="el" href="struct_lex_leq_constraint.html#d4f326f22b7b10deed6e90883b278893">LexLeqConstraint&lt; VarArray1, VarArray2, Less &gt;</a>, <a class="el" href="struct_min_constraint.html#c4e49eae46d364c307af1283fdb643c2">MinConstraint&lt; VarArray, MinVarRef &gt;</a>, <a class="el" href="struct_not_mod_constraint.html#3959cdfa9b6a866720891d0dd5f3762f">NotModConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_mod_constraint.html#5b17e65b896872af2723c48a29bf9317">ModConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_neq_constraint.html#9d7005270a1c5cc51f420940032d445d">NeqConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_not_occurrence_equal_constraint.html#363cd8ef0b1c31c614fe653647e6a183">NotOccurrenceEqualConstraint&lt; VarArray, Val, ValCount &gt;</a>, <a class="el" href="struct_pow_constraint.html#41f6f8c3365c48330b1a3810a8ca2228">PowConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_product_constraint.html#610ff2ba36dfddbd7c95a78d306359fa">ProductConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_less_equal_sum_constraint.html#3cfc311b60d37be28b9fe657694a3a8b">LessEqualSumConstraint&lt; VarArray, VarSum, is_reversed &gt;</a>, <a class="el" href="struct_light_less_equal_sum_constraint.html#7b1251cd4ab6ae952650009f8765ca8f">LightLessEqualSumConstraint&lt; VarRef, size, VarSum, is_reversed &gt;</a>, <a class="el" href="struct_bool_binary_s_a_t_constraint_dynamic.html#eb77c3d3f9a54921dc24ac5a4c06c662">BoolBinarySATConstraintDynamic&lt; VarArray &gt;</a>, <a class="el" href="struct_element_constraint_dynamic.html#96912e5f13e3921eba23ac3583c24759">ElementConstraintDynamic&lt; VarArray, Index, Result &gt;</a>, <a class="el" href="struct_watch_less_constraint.html#0dc872904febfa90338966e64c66c8c2">WatchLessConstraint&lt; Var1, Var2, Negated &gt;</a>, <a class="el" href="struct_literal_sum_constraint_dynamic.html#ad5ee6b3676e947f761d59256485361d">LiteralSumConstraintDynamic&lt; VarArray, ValueArray, VarSum &gt;</a>, <a class="el" href="struct_bool_less_sum_constraint_dynamic.html#7b23c4f0e7071eb7850700454758cd33">BoolLessSumConstraintDynamic&lt; VarArray, VarSum, VarToCount, is_reversed &gt;</a>, <a class="el" href="struct_vec_count_dynamic.html#a60ae7ffb1df06ff8fb4e2f8741d588a">VecCountDynamic&lt; VarArray1, VarArray2, Operator, is_reversed &gt;</a>, <a class="el" href="struct_vec_neq_dynamic.html#bcb776d6b1dfa939145acf5e18cac55f">VecNeqDynamic&lt; VarArray1, VarArray2, Operator &gt;</a>, <a class="el" href="struct_watch_in_range_constraint.html#6873f4b20b451b9190c49d3c4c40df46">WatchInRangeConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_in_set_constraint.html#81f59757e339e7d273aa87b3ddc8c9e2">WatchInSetConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_literal_constraint.html#77719e8b04f1b9fbff937b3a0c05cf26">WatchLiteralConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_not_in_range_constraint.html#aea5581a29ed095bc7109c4abb68a512">WatchNotInRangeConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_not_in_set_constraint.html#6fe4e32bbdf281e9473dc8768bcfc68a">WatchNotInSetConstraint&lt; Var &gt;</a>, and <a class="el" href="struct_watch_not_literal_constraint.html#f5a45e751e0e0ff4e36fdd246007211f">WatchNotLiteralConstraint&lt; Var &gt;</a>.</p>

<p>Definition at line <a class="el" href="constraint__abstract_8h-source.html#l00125">125</a> of file <a class="el" href="constraint__abstract_8h-source.html">constraint_abstract.h</a>.</p>

<p>References <a class="el" href="class_abstract_constraint.html#75f3857df083dd0fdba78e70346676f8">constraint_name()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="7d3bc6c554d81fd7abef354cfe28383c"></a><!-- doxytag: member="AbstractConstraint::reverse_constraint" ref="7d3bc6c554d81fd7abef354cfe28383c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_abstract_constraint.html">AbstractConstraint</a>* AbstractConstraint::reverse_constraint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the reverse of the current constraint. 
<p>
Used by rarification 
<p>Reimplemented in <a class="el" href="struct_abs_constraint.html#c41ae145be6fd7df03a82b472e0d388b">AbsConstraint&lt; AbsVarRef1, AbsVarRef2 &gt;</a>, <a class="el" href="struct_and_constraint.html#10cef74ac3e75c49e1ad6b0933f03563">AndConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_difference_constraint.html#ea53832db75d6523725e844af7a52e27">DifferenceConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_div_constraint.html#1ebb5d51b3efd2c53415abcb978158ac">DivConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_element_constraint.html#8b94c768d1d857b66b008c6d197d6627">ElementConstraint&lt; VarArray, IndexRef, VarRef &gt;</a>, <a class="el" href="struct_leq_constraint.html#e2bae4b3cd3aee95b7fe273376e34443">LeqConstraint&lt; VarRef1, VarRef2, Offset &gt;</a>, <a class="el" href="struct_lex_leq_constraint.html#ff767548efe3e016121b2c3989bfc31f">LexLeqConstraint&lt; VarArray1, VarArray2, Less &gt;</a>, <a class="el" href="struct_min_constraint.html#258d5f7e5da527bb6f00f9414dcb0b80">MinConstraint&lt; VarArray, MinVarRef &gt;</a>, <a class="el" href="struct_mod_constraint.html#af5dabca581e216cabd971fe588c00fb">ModConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_neq_constraint.html#e9bd208a79d03bc018c8ed8d880a2481">NeqConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_pow_constraint.html#2a3d0c174a457ee2ce19efa2804f4724">PowConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_product_constraint.html#9e45a239eb86215bfa05ddf8b055e0e6">ProductConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_less_equal_sum_constraint.html#e3363955dea58569a1f6dfcb460e42d0">LessEqualSumConstraint&lt; VarArray, VarSum, is_reversed &gt;</a>, <a class="el" href="struct_light_less_equal_sum_constraint.html#27ff1763063a500105747c34b9d014d3">LightLessEqualSumConstraint&lt; VarRef, size, VarSum, is_reversed &gt;</a>, <a class="el" href="struct_element_constraint_dynamic.html#bdcbf5abc355ce3a0d533984507cd5a8">ElementConstraintDynamic&lt; VarArray, Index, Result &gt;</a>, <a class="el" href="struct_watch_less_constraint.html#e18caaa5e4e64db8dd20d4076cdd3cee">WatchLessConstraint&lt; Var1, Var2, Negated &gt;</a>, <a class="el" href="struct_bool_less_sum_constraint_dynamic.html#9e8a92df90410b03fa75561df8e11b28">BoolLessSumConstraintDynamic&lt; VarArray, VarSum, VarToCount, is_reversed &gt;</a>, <a class="el" href="struct_vec_count_dynamic.html#a8fc5bb72706bea70882a230923f1985">VecCountDynamic&lt; VarArray1, VarArray2, Operator, is_reversed &gt;</a>, and <a class="el" href="struct_vec_neq_dynamic.html#0b4d6bd2c47d01ceccfc5e496824046e">VecNeqDynamic&lt; VarArray1, VarArray2, Operator &gt;</a>.</p>

<p>Definition at line <a class="el" href="constraint__abstract_8h-source.html#l00133">133</a> of file <a class="el" href="constraint__abstract_8h-source.html">constraint_abstract.h</a>.</p>

<p>References <a class="el" href="class_abstract_constraint.html#75f3857df083dd0fdba78e70346676f8">constraint_name()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<a class="anchor" name="e7da3594511a334d35053e3c68a76e87"></a><!-- doxytag: member="AbstractConstraint::full_propagate" ref="e7da3594511a334d35053e3c68a76e87" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AbstractConstraint::full_propagate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a full round of propagation and sets up any data needs by <a class="el" href="class_abstract_constraint.html#8628fdd06ba1cba4ce6005c0404e2256" title="Iterative propagation function.">propagate()</a>. 
<p>
This function can be called during search if the function is reified 
<p>Implemented in <a class="el" href="struct_abs_constraint.html#4af0bfaddd395e7f9b337ff1765c5b2c">AbsConstraint&lt; AbsVarRef1, AbsVarRef2 &gt;</a>, <a class="el" href="struct_and_constraint.html#88cb8f69340c0a12d1204a8ccf2636a3">AndConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_constant_constraint.html#35198e5e048368f6ff9abdafc5ed49f3">ConstantConstraint&lt; truth &gt;</a>, <a class="el" href="struct_difference_constraint.html#68f39e05b9732831a7f254afbb77b1c5">DifferenceConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_div_constraint.html#68986fc2f09a2969fc9ba7bb4235766a">DivConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_element_constraint.html#56eb6cceef8a39608e5d44798f8c88fa">ElementConstraint&lt; VarArray, IndexRef, VarRef &gt;</a>, <a class="el" href="struct_reified_equal_constraint.html#b203265cadade202b28df2d0b910a557">ReifiedEqualConstraint&lt; EqualVarRef1, EqualVarRef2, BoolVarRef &gt;</a>, <a class="el" href="struct_g_a_c_table_constraint.html#e40d421e639d96eab0f4b8df27b92485">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_g_a_c_table_constraint.html#e40d421e639d96eab0f4b8df27b92485">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_g_a_c_table_constraint.html#e40d421e639d96eab0f4b8df27b92485">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_g_a_c_table_constraint.html#e40d421e639d96eab0f4b8df27b92485">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_leq_constraint.html#98505a386d8bb48b8b59f2d001d35ff2">LeqConstraint&lt; VarRef1, VarRef2, Offset &gt;</a>, <a class="el" href="struct_lex_leq_constraint.html#7d7617f97b9dd32f67712f65d150ca03">LexLeqConstraint&lt; VarArray1, VarArray2, Less &gt;</a>, <a class="el" href="struct_min_constraint.html#9eb30efb756d9470f53d3b0c6df0de46">MinConstraint&lt; VarArray, MinVarRef &gt;</a>, <a class="el" href="struct_not_mod_constraint.html#3092b913995d6e895444ecc7f4999d76">NotModConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_mod_constraint.html#e5d4af8c2f919d85e14cacd326ec3fac">ModConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_neq_constraint.html#502722963fd4f0ff415603de044908c6">NeqConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_not_occurrence_equal_constraint.html#bbf05e14d670e5b15eb3e8fd1be04466">NotOccurrenceEqualConstraint&lt; VarArray, Val, ValCount &gt;</a>, <a class="el" href="struct_pow_constraint.html#f5abd1152fd47d1bc2266648febf2215">PowConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_product_constraint.html#a5f2b312e2980a8bd8af7b06d31d6046">ProductConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_less_equal_sum_constraint.html#4ce9e1e5fa3425cede3a5a5c08791223">LessEqualSumConstraint&lt; VarArray, VarSum, is_reversed &gt;</a>, <a class="el" href="struct_light_less_equal_sum_constraint.html#534de4777e5831e74038da79b052e55d">LightLessEqualSumConstraint&lt; VarRef, size, VarSum, is_reversed &gt;</a>, <a class="el" href="struct_bool_binary_s_a_t_constraint_dynamic.html#7004335bf25b3f8018d0d946c36fd878">BoolBinarySATConstraintDynamic&lt; VarArray &gt;</a>, <a class="el" href="struct_element_constraint_dynamic.html#45f6ca0662af8522d12fee16a33a1a3a">ElementConstraintDynamic&lt; VarArray, Index, Result &gt;</a>, <a class="el" href="struct_watch_less_constraint.html#301329d120ee5906b4ed5dba2fca65b2">WatchLessConstraint&lt; Var1, Var2, Negated &gt;</a>, <a class="el" href="struct_literal_sum_constraint_dynamic.html#6248dc864179acf6971ed4b46c9138d5">LiteralSumConstraintDynamic&lt; VarArray, ValueArray, VarSum &gt;</a>, <a class="el" href="struct_bool_less_sum_constraint_dynamic.html#9e61000ce6eecd92ce36f7fce7b46a83">BoolLessSumConstraintDynamic&lt; VarArray, VarSum, VarToCount, is_reversed &gt;</a>, <a class="el" href="struct_vec_count_dynamic.html#d4bd7232f647ea7f02554889906839dd">VecCountDynamic&lt; VarArray1, VarArray2, Operator, is_reversed &gt;</a>, <a class="el" href="struct_vec_neq_dynamic.html#7d324489457c4e604adc37bf84da4097">VecNeqDynamic&lt; VarArray1, VarArray2, Operator &gt;</a>, <a class="el" href="struct_watch_in_range_constraint.html#b451ba486a2aaf99710708866beaded0">WatchInRangeConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_in_set_constraint.html#d0ffe74bb2ddbacb0a8e7de380c9c37d">WatchInSetConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_literal_constraint.html#ef434e47780d37f7ccc51a2e473de1b1">WatchLiteralConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_not_in_range_constraint.html#537fa739bfa66247de33f09b3b60fb6c">WatchNotInRangeConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_not_in_set_constraint.html#c871852283c43a505d1303d44541bf0c">WatchNotInSetConstraint&lt; Var &gt;</a>, and <a class="el" href="struct_watch_not_literal_constraint.html#ee80514b86bd66042733a5438aaeb02c">WatchNotLiteralConstraint&lt; Var &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="f818b650a0c4f3f50c6ab2cad5817ecf"></a><!-- doxytag: member="AbstractConstraint::special_check" ref="f818b650a0c4f3f50c6ab2cad5817ecf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AbstractConstraint::special_check           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allows functions to activate a special kind of trigger, run only after the normal queue is empty. 
<p>Definition at line <a class="el" href="constraint__abstract_8h-source.html#l00177">177</a> of file <a class="el" href="constraint__abstract_8h-source.html">constraint_abstract.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e0f1648011903a59b830ce4585e2d2b2"></a><!-- doxytag: member="AbstractConstraint::check_assignment" ref="e0f1648011903a59b830ce4585e2d2b2" args="(DomainInt *v, int v_size)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual BOOL AbstractConstraint::check_assignment           </td>
          <td>(</td>
          <td class="paramtype">DomainInt *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if an assignment is satisfied. 
<p>
This takes the variable order returned by, and is mainly only used by, get_table_constraint() 
<p>Implemented in <a class="el" href="struct_abs_constraint.html#2364b2e1fc32122531c8354b3751c70e">AbsConstraint&lt; AbsVarRef1, AbsVarRef2 &gt;</a>, <a class="el" href="struct_and_constraint.html#bdd9bfddb1d838fcea22878da54c6918">AndConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_constant_constraint.html#5e980037efb002ef44487e7e83ee9dda">ConstantConstraint&lt; truth &gt;</a>, <a class="el" href="struct_difference_constraint.html#4f59f3fbdc6e73705c4d984422aaf479">DifferenceConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_div_constraint.html#ce6320594fac7bd799311d6d5551f6cd">DivConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_element_constraint.html#f8be91d72620314afae7f0c3aa6f1f6a">ElementConstraint&lt; VarArray, IndexRef, VarRef &gt;</a>, <a class="el" href="struct_reified_equal_constraint.html#da188eaf36549322877dd1b92b471f68">ReifiedEqualConstraint&lt; EqualVarRef1, EqualVarRef2, BoolVarRef &gt;</a>, <a class="el" href="struct_g_a_c_table_constraint.html#cef52c282fa618ec9c4ed6db23353c5a">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_g_a_c_table_constraint.html#cef52c282fa618ec9c4ed6db23353c5a">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_g_a_c_table_constraint.html#cef52c282fa618ec9c4ed6db23353c5a">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_g_a_c_table_constraint.html#cef52c282fa618ec9c4ed6db23353c5a">GACTableConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_leq_constraint.html#36b7825de7af3f449aa0cc81ee7dda21">LeqConstraint&lt; VarRef1, VarRef2, Offset &gt;</a>, <a class="el" href="struct_lex_leq_constraint.html#137e261485d0f37cb9efa286b0bb1a3e">LexLeqConstraint&lt; VarArray1, VarArray2, Less &gt;</a>, <a class="el" href="struct_min_constraint.html#deca1146b92a574964f408fb873a4877">MinConstraint&lt; VarArray, MinVarRef &gt;</a>, <a class="el" href="struct_not_mod_constraint.html#3be966ce007537e02aee99c363eb680d">NotModConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_mod_constraint.html#dbee523f27a70f37ca06db400bf62942">ModConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_neq_constraint.html#dc9fc609dc54148953afa49a2424ecdd">NeqConstraint&lt; VarArray &gt;</a>, <a class="el" href="struct_not_occurrence_equal_constraint.html#1f36cd2aeec3e81d3a994cdbb0ec0f80">NotOccurrenceEqualConstraint&lt; VarArray, Val, ValCount &gt;</a>, <a class="el" href="struct_pow_constraint.html#2f15f977b3afc37ab1468f497ceeab4e">PowConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_product_constraint.html#6f715594091b405c91aaab8129763b01">ProductConstraint&lt; VarRef1, VarRef2, VarRef3 &gt;</a>, <a class="el" href="struct_less_equal_sum_constraint.html#f9ad6d91cbc13e0f8c9785769f66c27a">LessEqualSumConstraint&lt; VarArray, VarSum, is_reversed &gt;</a>, <a class="el" href="struct_light_less_equal_sum_constraint.html#7411dd3c0e7049259c7a779dba915bba">LightLessEqualSumConstraint&lt; VarRef, size, VarSum, is_reversed &gt;</a>, <a class="el" href="struct_bool_binary_s_a_t_constraint_dynamic.html#cb00482c6f2c0f588c59691dc7442c38">BoolBinarySATConstraintDynamic&lt; VarArray &gt;</a>, <a class="el" href="struct_element_constraint_dynamic.html#6e163bf3339b06f4aaa6149fbc4b6230">ElementConstraintDynamic&lt; VarArray, Index, Result &gt;</a>, <a class="el" href="struct_watch_less_constraint.html#f51e282dbae9a84a257e23a4bcf925d9">WatchLessConstraint&lt; Var1, Var2, Negated &gt;</a>, <a class="el" href="struct_literal_sum_constraint_dynamic.html#2f5f988983f08a7c26ea0b892c42ced6">LiteralSumConstraintDynamic&lt; VarArray, ValueArray, VarSum &gt;</a>, <a class="el" href="struct_bool_less_sum_constraint_dynamic.html#5ceda280ab1cd65602ee8c769f9cba31">BoolLessSumConstraintDynamic&lt; VarArray, VarSum, VarToCount, is_reversed &gt;</a>, <a class="el" href="struct_vec_count_dynamic.html#b9e229a0f5df1a85eba2e8915824601c">VecCountDynamic&lt; VarArray1, VarArray2, Operator, is_reversed &gt;</a>, <a class="el" href="struct_vec_neq_dynamic.html#6aa01afe1ad62a2e4e738d481889c3fb">VecNeqDynamic&lt; VarArray1, VarArray2, Operator &gt;</a>, <a class="el" href="struct_watch_in_range_constraint.html#0c7e83623c5441f689c7501b17297e49">WatchInRangeConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_in_set_constraint.html#b0ae510343bde61397768a329964311c">WatchInSetConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_literal_constraint.html#61d1e0875819d76f6da5dc3da4ef7341">WatchLiteralConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_not_in_range_constraint.html#db38d7a64bb27c39a0b601fa9264f8f7">WatchNotInRangeConstraint&lt; Var &gt;</a>, <a class="el" href="struct_watch_not_in_set_constraint.html#526572f22c2fab5dbf5218acd0fa8227">WatchNotInSetConstraint&lt; Var &gt;</a>, and <a class="el" href="struct_watch_not_literal_constraint.html#1da04e21820e14ecb2d5d5a49d62bd93">WatchNotLiteralConstraint&lt; Var &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="587e70c5fc0270491535f77c9950b6d1"></a><!-- doxytag: member="AbstractConstraint::setup" ref="587e70c5fc0270491535f77c9950b6d1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AbstractConstraint::setup           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Actually creates the dynamic triggers. Calls dynamic_trigger_count from function to get the number of triggers required. 
<p>Reimplemented in <a class="el" href="class_parent_constraint.html#003f68680e5eb78a2494f59848db1f6a">ParentConstraint</a>.</p>

<p>Definition at line <a class="el" href="constraint__abstract_8h-source.html#l00208">208</a> of file <a class="el" href="constraint__abstract_8h-source.html">constraint_abstract.h</a>.</p>

<p>References <a class="el" href="constraint__abstract_8h-source.html#l00080">dynamic_trigger_count()</a>, <a class="el" href="constraint__abstract_8h-source.html#l00075">dynamic_trigger_start()</a>, and <a class="el" href="constraint__abstract_8h-source.html#l00061">stateObj</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="constraint__abstract_8h-source.html">constraint_abstract.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Apr 12 22:47:12 2009 for Minion by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
