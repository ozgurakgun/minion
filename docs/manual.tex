\documentclass{article}
% Subversion Identity $Id$ 
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{url}
\usepackage{graphics}
\usepackage{times}
\newcommand{\bfl}{\mbox{\boldmath $\lambda$}}
\newcommand{\bft}{\mbox{\boldmath $\tau$}}
\newcommand{\sbfl}{\mbox{\scriptsize\boldmath $\lambda$}}
\newcommand{\abs}{\mbox{abs}}
\newcommand{\Comment}[1]{}

\def\X{{\tt x}}
\def\Y{{\tt y}}
\def\Da{{\tt d1}}
\def\Db{{\tt d2}}
\def\Ra{{\tt r90}}
\def\Rb{{\tt r180}}
\def\Rc{{\tt r270}}
\def\BW{{\tt bw}}

\begin{document}

% ---------------------------------------------------------------------------
% PRELIMINARIES
% ---------------------------------------------------------------------------

\newpage

\pagestyle{empty}
\begin{center}
\vfill
{\LARGE Getting Started with {\sc Minion}}
\vfill
{\large Ian P. Gent,\\
Christopher A. Jefferson,\\
Ian Miguel\\
Karen E. Petrie and\\
Andrea M. Rendl}
\vfill
%{\Large {\sc Minion} Version 0.3.3}\\
{\Large {\sc Minion} Version 0.4}\\
~\\
{\Large {\sc Minion} Input Language 1}
%{\Large Manual Version 0.2}
\vfill
{\large{\today}}
\vfill
\end{center}

\newpage

\pagestyle{empty}
\setcounter{page}{1}
\pagestyle{plain}
\pagenumbering{roman}

\tableofcontents
%\listoffigures
%\listoftables

\newpage
\setcounter{page}{1}
\pagestyle{headings}
\pagenumbering{arabic}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}\label{sect_introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This manual introduces {\sc Minion}, a general-purpose solver for CSP/COP instances. 
It will cover installation issues (chapter ~\ref{sect_installation})  and give detailed information on how to model problems demonstrated by an example (chapter  ~\ref{sect_matrix}, ~\ref{sect_example}). The variable types and available
constraints are presented in chapter ~\ref{sect_variables} and ~\ref{sect_constraints}, respectively. The BNF of the input language can be found in chapter ~\ref{sect_input}. Important notes (containing bugs) about the current version are given in chapter ~\ref{sect_notes} and updated on a regularly basis. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Obtaining and Installing {\sc Minion}}\label{sect_installation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

{\sc Minion} can be obtained from:

\begin{small}
\begin{itemize}
\item \texttt{http://sourceforge.net/projects/minion}
\end{itemize}

To compile {\sc minion}:

\begin{verbatim}
On Linux: Make sure g++ is installed, type "./build-all.sh"
On Mac: Install the latest version of xcode, type "./build-all.sh"
On Windows: Install cygwin with g++, type "./build-all.sh"
\end{verbatim}
{\bf Warning:} Compilation can take around 30 minutes. It requires g++
version 3.2 or above (type \texttt{g++ -v} to
check version). 

In the {\tt bin} directory, there are two executables:

\begin{description}
\item[minion-debug] Debugging version. Does a range of extra consistency
checks and can be run through a debugger.
\item[minion] Optimised version.
\end{description}

Command-line arguments: the filename must appear last, but the other arguments may appear in any oder.   Behaviour if contradictory arguments are given (e.g. quiet and verbose) is not defined.
When run with no arguments, a brief help message is displayed.

\begin{itemize}
\item\ [-findallsols].   Find all solutions and count them.   This option is ignored if the problem contains any minimising or maximising objective.
\item\ [-timelimit] N. Stop after N seconds.
\item\ [-sollimit] N. Stop after finding N solutions.
\item\ [-nodelimit] N. Stop after N nodes are searched.
\item\ [-quiet]. Switch off output from instance parser.  (Default depends on compile-time options).
\item\ [-verbose]. Switch on output from instance parser.  (Default again depends on compile-time options.)
\item\ [-printsols].   Print each solution when it is found, including each improved solution when optimising.  This is the default.
\item\ [-noprintsols].   Do not print solutions.
\item\ [-dumptree]. Output the search tree. If you want details on how to use this, or if you want more information, please ask.
\item\ [-test].  A test option for checking and regression testing.   Example test instances which this can be run on are in the directory {\tt test\_instances}.   
\item\ [-fullprop]. Disable incremental propagation. This should always slow down search while producing exactly the same search tree.
\item\  [-varorder = ORDER]. Enables variable order ORDER. Please note that this flag is still in an experimental state, so 
        { \sc Minion}'s default variable ordering might be faster. ORDER can be any of the following : 
      \begin{itemize}
	\item\ [sdf].  Smallest domain first, then break ties with lex 
	\item\ [sdf-random]. Smallest domain first, break ties randomly
        \item\ [ldf]. Largest domain first
        \item\ [ldf-random]. Largest domain first, break ties randomly
	\item\ [random]. Random variable ordering
	\item\ [static]. Normal ordering without caching 
      \end{itemize}
\item\ [-sac-root]. Perform SGAC at the first node. 
\item\ [-ssac-root]. Perform SSGAC at the first node. 
\item\ filename.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Matrix Models in {\sc Minion}}\label{sect_matrix}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

{\sc Minion} is a general-purpose solver for CSP/COP {\em instances},
with an expressive input language based on the common constraint
modelling device of matrix models. In this context a matrix is a
$n$-dimensional object, which can be used to store CSP variables,
matrices allow ease of reference to these variables. In CSP a matrix
formulation employs one or more matrices of decision variables, with
constraints typically imposed on the rows, columns and planes of the
matrices.

To illustrate, consider the {\em Balanced Incomplete Block Design}
(BIBD, CSPLib problem 28), which is defined as follows: Given a
5-tuple of positive integers, $\langle v$, $b$, $r$, $k$,
$\lambda\rangle$, assign each of $v$ objects to $b$ blocks such that
each block contains $k$ distinct objects, each object occurs in
exactly $r$ different blocks and every two distinct objects occur
together in exactly $\lambda$ blocks. Despite its simplicity, the BIBD
has important practical applications, such as cryptography and
experimental design.

The matrix model for BIBD has $b$ columns and $v$ rows of 0/1 decision
variables. A `1' entry in row $i$, column $j$ represents the decision
to assign the $i$th object to the $j$th block. Each row is constrained
to sum to $r$, each column is constrained to sum to $k$ and the scalar
product of each pair of rows is constrained to equal $\lambda$. A
solution to the instance $\langle 7, 7, 3, 3, 1\rangle$ is given
below:

$\begin{pmatrix}0&0&0&0&1&1&1\cr
         0&0&1&1&0&0&1\cr
         0&1&0&1&0&1&0\cr
         0&1&1&0&1&0&0\cr
         1&0&0&1&1&0&0\cr
         1&0&1&0&0&1&0\cr
         1&1&0&0&0&0&1\end{pmatrix}$

Matrix models such as this have been identified as a very common
pattern in constraint modelling and support, for example, the
straightforward modelling of problems that involve finding a function
or relation --- indeed, one can view the BIBD as finding a relation
between objects and blocks.

{\sc Minion}'s input language supports the definition of one, two, and
three-dimensional matrices of decision variables (higher dimensions
can easily be created by using multiple matrices of smaller
dimension).  Furthermore, it provides direct access to matrix rows and
columns in recognition of the fact that most matrix models impose
constraints on them.

By focusing on matrix models {\sc Minion} is a lean, highly-optimised
constraint programming solver.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Variables}\label{sect_variables}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

{\sc Minion} supports 5 variable types. These are: 
\begin{enumerate}
\item \emph{0/1} variables, which are used very commonly for logical
expressions, and for encoding the characteristic functions of sets and
relations. Note that wherever a 01 variable can appear, the negation
of that variable can also appear. For instance, the first Boolean
variable (if any) is always $x0$. Its negation is identified by $nx0$.
\item \emph{Bounds} variables, where only the upper and lower bounds
of the domain are maintained. These domains must be continuous ranges
of integers i.e. holes can not be put in the domains of the variables.
\item \emph{Sparse Bounds} variables, where the domain is composed of
discrete values (e.g. \{1, 5, 36, 92\}), but only the upper and lower
bounds of the domain may be updated during search. Although the domain
of these variables is not a continuous range, any holes in the domains
must be there at time of specification, as they can not be added
during the solving process.
\item \emph{Discrete} variables, where the domain ranges from the
lower bound to the upper bound specified, but the deletion of any
domain element in this range is permitted. This means that holes can
be put in the domain of these variables.
\item \emph{Discrete Sparse} variables, where the domain is composed of discrete values, and any domain element may be removed. This is the most general variable type, it allows any integer value to be in the domain at specification time, and it allows any variable to be removed during the search process.
{\emph{Unfortunately this type of variable is not yet implemented.}}
\end{enumerate}
Sub-dividing the variable types in this manner affords the greatest opportunity for optimisation. In general, we recommend thinking of the variable types as a hierarchy, where 1 (0/1 variables) is the most efficient type, and 5 (Discrete Sparse Variables) is the least. The user should use the variable which is the highest in the hierarchy, yet encompasses enough information to provide a full model for the problem they are attempting to solve.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Constraints}\label{sect_constraints}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{\sc Minion} supports the following constraints. Note that it does NOT
support nesting of constraints. In all cases, a variable may be
replaced with a constant. {\sc Minion} supports a variety of
expressions on matrices (e.g. row, and column), and will automatically
flatten matrices of higher arity. See BNF in next section for details.


\subsection{Reification}

There are two different constraints imposing reification.

\begin{description}
\item \textbf{Reify} states that the assignment of a 0/1 variable
is 1 iff the constraint is satisfied:\\
\texttt{reify($\langle$constraint$\rangle$, $\langle$01var$\rangle$)}.

\item \textbf{Guide} states that  the reified constraint is entailed if the 
assignment to the 0/1 variable is 1. If otherwise, there will be no propagation done 
on the constraint. Please note that in upcoming versions of Minion the guide-constraint will be known as 
\texttt{guide}. %instead of \texttt{reifyimply}.
\\
\texttt{reifyimply($\langle$constraint$\rangle$, $\langle$01var$\rangle$)}.

\end{description}


\subsection{Reifiable constraints}

The following list presents constraints that are reifiable - mostly with
 \texttt{reifyimply}.  

\begin{description}
\item[All-Different] states that all the variables in a matrix are
assigned different variables/values.\\ 
\texttt{alldiff($\langle$matrix of
variables$\rangle$)}.

\item[$ \mathbf{\neq}$] states that a variable (\texttt{var1}) is not
equal to a another variable (\texttt{var2}):\\
\texttt{diseq($\langle$var1$\rangle$, $\langle$var2$\rangle$)}.

\item[$\mathbf{=}$] states that a variable (\texttt{var1}) is equal to
another variable (\texttt{var2}):\\
\texttt{eq($\langle$var1$\rangle$, $\langle$var2$\rangle$)}.

\item[Element] states that the variable at the index of the matrix
specified by the assignment to \texttt{var1} is equal to the
assignment of \texttt{var2}:\\ \texttt{element($\langle$matrix of
variables$\rangle$, $\langle$var1$\rangle$, $\langle$var2$\rangle$)}.

\item[GACelement] states that the variable at the index of the matrix
specified by the assignment to \texttt{var1} is equal to the
assignment of \texttt{var2} preserving GAC:\\ \texttt{element($\langle$matrix of
variables$\rangle$, $\langle$var1$\rangle$, $\langle$var2$\rangle$)}.\\
\emph{Note that you may find that the constraint \texttt{watchelement} works faster: these two constraints should always perform the same propagations as each other.}
 

\item[$\mathbf{\leq}$] states that a variable (\texttt{var1}) is less
than or equal to another variable (\texttt{var2}) plus a constant (to
obtain $<$ use $-1$ for the constant):\\
\texttt{ineq($\langle$var1$\rangle$, $\langle$var2$\rangle$,
$\langle$const$\rangle$)}.

\item[Lexicographically $\mathbf{\leq}$] states that a matrix of
variables (\texttt{mat1}) is lexicographically less than or equal to
another matrix of variables (\texttt{mat2}):\\
\texttt{lexleq($\langle$mat1$\rangle$, $\langle$mat2$\rangle$)}.

\item[Lexicographically $\mathbf{<}$] states that a matrix of
variables (\texttt{mat1}) is less than another matrix of variables
(\texttt{mat2}):\\
\texttt{lexless($\langle$mat1$\rangle$, $\langle$mat2$\rangle$)}.

\item[Maximum] states that the maximum assignment among a matrix of
variables is equal to the assignment of a variable, (\texttt{var}):\\
\texttt{max($\langle$matrix of variables$\rangle$,
$\langle$var$\rangle$)}.

\item[Minimum] states that the minimum assignment among a matrix of
variables is equal to the assignment of a variable, (\texttt{var}):\\
\texttt{min($\langle$matrix of variables$\rangle$,
$\langle$var$\rangle$)}.

\item[Occurrence] states that a given value is assigned to a specified
number of variables in a matrix:\\ \texttt{occurrence($\langle$matrix
of variables$\rangle$, $\langle$value$\rangle$,
$\langle$count$\rangle$)}.

\item[Product] states that a given variable (\texttt{var1}) multiplied
by another variable (\texttt{var2}) is equal to a third variable
(\texttt{var3}):\\ \texttt{Product($\langle$var1$\rangle$,
$\langle$var2$\rangle$, $\langle$var3$\rangle$)}.

\item[Sum $\mathbf{\geq}$] states that the sum of the variables in a
matrix is greater than or equal to the assignment of a single
variable:\\ \texttt{sumgeq($\langle$matrix of variables$\rangle$,
$\langle$var$\rangle$)}.

\item[Sum $\mathbf{\leq}$] states that the sum of the variables in a
matrix is less than or equal to the assignment of a single variable:\\
\texttt{sumleq($\langle$matrix of variables$\rangle$,
$\langle$var$\rangle$)}.

\begin{quote}
{\em Note: In the current version of {\sc Minion}, there is no 
constraint for Sum$=$.  This has to be achieved with a 
Sum$\mathbf{\leq}$ and a 
Sum$\mathbf{\geq}$.}
\end{quote}

\item[Weighted Sum $\mathbf{\leq}$] states that the scalar product of
a matrix of variables and a matrix of constants is less than or equal
to the assignment of a single variabl:\\
\texttt{weightedsumleq($\langle$matrix of constants$\rangle$,
$\langle$matrix of variables$\rangle$, $\langle$variable$\rangle$)}.

\item[Weighted Sum $\mathbf{\geq}$] states that the scalar product of
a matrix of variables and a matrix of constants is greater than or
equal to the assignment of a single variable:\\
\texttt{weightedsumgeq($\langle$matrix of constants$\rangle$,
$\langle$matrix of variables$\rangle$, $\langle$variable$\rangle$)}.


\subsection{Non-reifiable constraints}

\item[MinusEq] states that a variable equals the negation of another variable.
\\
\texttt{minuseq($\langle$variable$\rangle$, $\langle$variable$\rangle$)}

\item[Element (watched literals)] states that the variable at the index of the matrix
specified by the assignment to \texttt{var1} is equal to the
assignment of \texttt{var2} using watched literals.  Like \texttt{gacelement}, this constraint preserves GAC:\\ 
\texttt{watchelement($\langle$matrix of
variables$\rangle$, $\langle$var1$\rangle$, $\langle$var2$\rangle$)}.

\item[Sum $\mathbf{=}$ (watched literals)] states that the sum of the variables in a
matrix is equal to the assignment of a single variable, using watched literals. \\
\texttt{litsumeq($\langle$matrix of variables$\rangle$, $\langle$matrix of constants$\rangle$)}


\item[Sum $\mathbf{\geq}$ (watched literals)] states that the sum of the variables in a
matrix is greater than or equal to the assignment of a single
variable, using watched literals:\\ \texttt{watchsumgeq($\langle$matrix of variables$\rangle$,
$\langle$var$\rangle$)}.

\item[Sum $\mathbf{\leq}$ (watched literals)] states that the sum of the variables in a
matrix is less than or equal to the assignment of a single variable, using watched literals:\\
\texttt{watchsumleq($\langle$matrix of variables$\rangle$,
$\langle$var$\rangle$)}.

\item[Table] allows the specification of an extensional constraint. 
The set of tuples should be given in strictly increasing lexicographic order.\\
\textbf{Note}: The implementation has been changed and details can be found in the CPPOD-technical
report\footnote{http://www.dcs.st-and.ac.uk/~cppod/publications/reports/cppod-19-2006.pdf}.\\
\texttt{table($\langle$matrix of variables$\rangle$, $\langle$tuples$\rangle$)}

\item[Vector $ \mathbf{\neq}$ (watched literals)] states that a vector (\texttt{vector1}) is not
equal to a another vector (\texttt{vector2}), using watched literals:\\
\texttt{watchvecneq($\langle$vector1$\rangle$, $\langle$vector2$\rangle$)}.

\item[Power] the power constraint, with variables in the following order $x^y = z$. It is only available for positive domains.\\
\texttt{pow( $\langle$variable$\rangle$,  $\langle$variable$\rangle$,  $\langle$variable$\rangle$ ) }

\end{description}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Input format}\label{sect_input}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%A formal outline of the input format for Input Format Version 1 is shown below.


% the order of constraints does not matter
% what are variablevectors, names and tuples?
% how do variables get to their names?
% variableName can be substutued by constants


Here are some important notes concerning modelling in the input format.

\begin{description}

  \item[Variable names]  variable names start with a specific letter 
  (\texttt{x} for simple variables, \texttt{v} for 1-dimensional matrices
  (vectors), \texttt{m} for 2-dimensional matrices and \texttt{t} for
  tuples), followed by the order in which they were defined  (staring with \texttt{0}). 
  For example, if there are 4 boolean variables, 5 bounds variables,
  and 3 1-dimensional matrices(vectors) declared, 
  the first boolean variable has the name \texttt{x0} and the second
  bounds variable has the name \texttt{x5} and the third vector the
  name \texttt{v2}.  
  \item[Constraint order] the order in which constraints are stated does not matter
  \item[Printing variables] the expression to be printed in the \texttt{print} statement
  has to be a defined 1- or 2-dimensional matrix.    
  \item[Constants] a variable can always be substitued by a constant (in constraints)
  \item[Variable orders] when applying a variable order, the variables defined in the
  \textit{variableOrder} will be put under the order  that was imposed in the
  textit{valueOrder} (\texttt{a} for acending
  and \texttt{d} for descending). Empty lists \texttt{[] []} correspond to no ordering.
  \item[Comments] comments are only allowed in the header
  \item[Tuplelists] defined tuplelists can be referenced by their name which is
  composed by \texttt{t} followed by the order (beginning from 0) in which they were
  defined. For example \texttt{t2} stands for the third tuple.  
\end{description}



\subsection{Notation}

This is the grammar of the input format of Minion. Expressions written
in \textit{italic} font are non-terminals and those written in 
\texttt{typesetter} are terminals. Any expression written in neither
of these fonts correspond to integer values whose purpose are
described by the expressions. The non-terminal \textit{Variable} stands for a 
variable name as described above.

 
\begin{center}
\begin{itemize}
  \item $a *$ stands for zero or more occurences of $a$
  \item $a +$ stands for one or more occurences of $a$
  \item $a \mid b$ stands for $a$ or $b$

\end{itemize}
\end{center}

\noindent

\subsection{Model}
\begin{tabular}{rcl}
\textit{MinionInput}& ::= & \textit{MinionHeader} \\
                    &     & \textit{VariableDeclarations} \\
                    &     & \textit{VariableOrder} \\
                    &     & \textit{ValueOrder} \\
                    &     & \textit{MatrixDeclarations} \\
                    &     & \textit{TupleLists} \\
                    &     & \texttt{objective} \textit{ObjectiveExpression} \\ 
		    &     & \texttt{print} \textit{PrintExpression} \\
                    &     & \textit{Constraints} \\


\end{tabular}


\subsection{Declarations}
\begin{tabular}{rcl}
\textit{MinionHeader} & ::= & \texttt{MINION} inputVersionNumber\\
                     &     &  \# \textit{comments}  \\

\textit{VariableDeclarations}& ::=  
                    &  amountOf01Variables  \\
               &     &  amountOfBoundsVariables \\
               &     &  \textit{Bounds}*  \\
               &     &  amountOfSparseBoundsVariables \\
               &     &  \textit{SparseBounds}* \\
               &     &  amountOfDiscreteVariables \\
               &     & \textit{Bounds}* \\
               &     & amountOfSparseDiscreteVariables \\
               &     & \textit{SparseBounds}* \\

 \textit{Bounds}& ::= & lowerBound upperBound amountOfVariables\\ 

 \textit{SparseBounds}& ::= & \{ \textit{DomainElements} \} amountOfVariables \\

\textit{DomainElements}& ::= & value $\mid$ \\
                       &   & \textit{DomainElements} , value \\

\textit{VariableOrder} & ::= & [ \textit{VariableList} ] $\mid$ [ ]\\

\textit{ValueOrder} & ::= & [ \textit{OrderList} ]  $\mid$ [ ]\\

\textit{OrderList} & ::= & \textit{Order} $\mid$ \\
                   &      & \textit{OrderList} \texttt{,} \textit{Order} \\

\textit{Order} &  ::= & \texttt{a}  $\mid$ \texttt{d} \\

\textit{MatrixDeclarations} & ::= & amountOf1DimensionalMatrices \\
                           &     & \textit{1DimensionalMatrix}+ \\
                           &     & amountOf2DimensionalMatrices \\
                           &     & \textit{2DimensionalMatrix}+ \\
                           &     & amountOf3DimensionalMatrices \\
                           &     & \textit{3DimensionalMatrix}+ \\

\textit{TupleListsDefintion}& ::= & \texttt{tuplelists} amountOfTupleLists \\
                            &     & \textit{TupleDefinitions}+ $\mid$ $\epsilon$\\

\textit{TupleDefinitions} & ::= & amountOfTuples tupleLength  \\
                          &     & tupleValues+  \\

\textit{ObjectiveExpression}& ::= & \texttt{none} $\mid$ \\
                            &     & \texttt{minimising} \textit{Variable} $\mid$ \\
                            &     & \texttt{maximising} \textit{Variable} \\

\textit{PrintExpression} & ::= & \texttt{none} $\mid$ \\
                         &     & \textit{Defined1DimensionalMatrixName} $\mid$ \\
                         &     & \textit{Defined2DimensionalMatrixName}  \\

\textit{ConstantList}  & ::= & constant $\mid$\\
                       &     & \textit{ConstantList} \texttt{,} constant \\     

\textit{VariableList}& ::= & \textit{Variable} $\mid$ \\   
                       &   & \textit{VariableList} \texttt{,} \textit{Variable} \\

\textit{1DimensionalMatrix} & ::= & [ \textit{ConstantList} ] $\mid$ [ ] \\

\textit{2DimensionalMatrix} & ::= & [ \textit{1DimensionalMatrix}+ ] $\mid$ [ ]\\

\textit{3DimensionalMatrix} & ::= & [ \textit{2DimensionalMatrix}+ ] $\mid$ [ ] \\

\end{tabular}


\subsection{Constraints}
\begin{tabular}{rcl}


\textit{Constraints}  & ::= & \textit{ReifiableConstraint} $\mid$ \\
                      &     & \texttt{reify(} \textit{ReifiableConstraint} \texttt{,} \textit{Variable} \texttt{)} $\mid$ \\
                      &     & \texttt{reifyImplies(} \textit{ReifiableConstraint}  \texttt{,} \textit{Variable} \texttt{)} $\mid$\\
                      &     & \texttt{table(} \textit{VariableVector} \texttt{,} \textit{tuples} \texttt{)} $\mid$ \\        
                      &     & \texttt{watchsumleq(} \textit{VariableVector} \texttt{,} \textit{VariableVector} \texttt{)}  $\mid$\\
                      &     & \texttt{watchsumgeq(} \textit{VariableVector} \texttt{,} \textit{VariableVector} \texttt{)}  $\mid$\\
                      &     & \texttt{watchvecneq(} \textit{VariableVector} \texttt{,} \textit{VariableVector} \texttt{)} $\mid$ \\
                      &     & \texttt{watchelement(} \textit{VariableVector} \texttt{,} \textit{Variable} \texttt{,} \textit{Variable} \texttt{)} $\mid$ \\
                      &     & \texttt{minusequal(} \textit{Variable} \texttt{,} \textit{Variable} \texttt{)}  $\mid$\\
                      &     & \texttt{litsumequal(} \textit{VariableVector} \texttt{,} [ \textit{ConstantList} ] \texttt{)} $\mid$ \\
                      &     & \texttt{pow(} \textit{Variable} \texttt{,} \textit{Variable} \texttt{,} \textit{Variable}\texttt{)} $\mid$ \\


\textit{ReifiableConstraints} & ::= &  \texttt{allDiff(} \textit{VariableVector} \texttt{)} $\mid$ \\
                &     & \texttt{eq(} \textit{Variable} \texttt{,} \textit{Variable} \texttt{)} $\mid$ \\
                &     & \texttt{diseq(} \textit{Variable} \texttt{,} \textit{Variable} \texttt{)} $\mid$ \\
                &     & \texttt{ineq(} \textit{Variable} \texttt{,} \textit{Variable} \texttt{,} constant \texttt{)} $\mid$ \\
                &     & \texttt{element(} \textit{VariableVector} \texttt{,} \textit{Variable} \texttt{,} \textit{Variable}\texttt{)} $\mid$ \\
                &     & \texttt{gacelement(} \textit{VariableVector} \texttt{,} \textit{Variable} \texttt{,} \textit{Variable}\texttt{)} $\mid$ \\
                &     & \texttt{min(} \textit{VariableVector} \texttt{,} \textit{Variable} \texttt{)} $\mid$ \\
                &     & \texttt{max(} \textit{VariableVector} \texttt{,} \textit{Variable} \texttt{)} $\mid$ \\
                &     & \texttt{lexleq(} \textit{VariableVector} \texttt{,} \textit{VariableVector} \texttt{)} $\mid$ \\
                &     & \texttt{lexless(} \textit{VariableVector} \texttt{,} \textit{VariableVector} \texttt{)} $\mid$ \\
                &     & \texttt{occurence(} \textit{VariableVector} \texttt{,} constant \texttt{,} constant\texttt{)} $\mid$ \\
                &     & \texttt{product(} \textit{VariableVector} \texttt{,} \textit{Variable} \texttt{)} $\mid$ \\
                &     & \texttt{product(} \textit{VariableVector} \texttt{,} [ \textit{ConstantList} ] \texttt{,} \textit{Variable}\texttt{)} $\mid$ \\
                &     & \texttt{sum(} \textit{VariableVector} \texttt{,} \textit{Variable} \texttt{)}  $\mid$\\
                &     & \texttt{weightedsumleq(} \textit{VariableVector} \texttt{,} [ \textit{ConstantList} ] \texttt{,} \textit{Variable}\texttt{)} $\mid$ \\
                &     & \texttt{weightedsumgeq(} \textit{VariableVector} \texttt{,} [ \textit{ConstantList} ] \texttt{,} \textit{Variable}\texttt{)} \\



\textit{VariableVector}  & ::= & [ \textit{ConstantList} ] $\mid$\\
                         &     & [ \textit{VariableList}  ] $\mid$ \\
                         &     & \textit{1DimensionalMatrix} $\mid$\\
                         &     & \textit{2DimensionalMatrix} $\mid$\\
                         &     & \textit{3DimensionalMatrix} $\mid$\\
                         &     & \texttt{row(}\textit{2DimensionalMatrix} \texttt{,} index \texttt{)} $\mid$\\
                         &     & \texttt{col(}\textit{2DimensionalMatrix} \texttt{,} index \texttt{)} $\mid$\\
                         &     & \texttt{rowX(}\textit{3DimensionalMatrix} \texttt{,} index \texttt{,} index \texttt{)} $\mid$\\
                         &     & \texttt{rowY(}\textit{3DimensionalMatrix} \texttt{,} index \texttt{,} index \texttt{)} $\mid$\\
                         &     & \texttt{colX(}\textit{3DimensionalMatrix} \texttt{,} index \texttt{,} index \texttt{)} $\mid$\\
                         &     & \texttt{colY(}\textit{3DimensionalMatrix} \texttt{,} index \texttt{,} index \texttt{)} \\




\end{tabular}













%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Comment{


\setlength{\tabcolsep}{0mm}
\begin{tabular}{ll}
\multicolumn{2}{l}{$<$MinionInput$>$ ::=} \\
\hspace*{2mm} &MINION $<$versionnumber$>$ \\
              &$<$comments$>$\\
              &$<$noOf01Vars$>$\\
              &$<$noOfBoundsVars$>$ \{$<$lb$>$ $<$ub$>$ $<$number$>$\}\\
              &$<$noOfSparseBoundsVars$>$ \{'\{' $<$elem$>$\{,$<$elem$>$\}'\}'$<$number$>$\}\\
              &$<$noOfDiscreteVars$>$ \{$<$lb$>$ $<$ub$>$ $<$number$>$\}\\
              &$<$noOfSparseDiscreteVars$>$ \{'\{' $<$elem$>$\{,$<$elem$>$\}'\}'$<$number$>$\}\\
              &$<$variableOrder$>$\\
              &$<$valueOrder$>$\\
              &$<$noOf1dMatrices$>$ \{$<$literalVar1dMatrix$>$\}\\
              &$<$noOf2dMatrices$>$ \{$<$literalVar2dMatrix$>$\}\\
              &$<$noOf3dMatrices$>$ \{$<$literalVar3dMatrix$>$\}\\
              & $<$tuplelistsExpression$>$ \\
              &objective $<$objectiveExpression$>$\\
              &print $<$printExpression$>$\\
              &\{$<$constraint$>$\}
\end{tabular}
\vspace*{1mm}

\noindent
\setlength{\tabcolsep}{0mm}
\begin{tabular}{ll}
\multicolumn{2}{l}{$<$tuplelistsExpression$>$ ::=}\\
\hspace*{2mm} &   tuplelists $<$num\_of\_tuplelists$>$   \\
\hspace*{2mm} &   [ $<$tuplelist$>$ ] \\
\end{tabular}
\vspace*{1mm}

\noindent
\setlength{\tabcolsep}{0mm}
\begin{tabular}{ll}
\multicolumn{2}{l}{$<$tuplelist$>$ ::=}\\
\hspace*{2mm} &   $<$num\_tuples$>$ \ $<$tuplelength$>$\  $<$tuplevalues$> $ \  $|$ \\
\end{tabular}
\vspace*{1mm}


\noindent
\setlength{\tabcolsep}{0mm}
\begin{tabular}{ll}
\multicolumn{2}{l}{$<$objectiveExpression$>$ ::=}\\
\hspace*{2mm} & 'none' $|$ 'minimising' $<$var$>$ $|$ 'maximising' $<$var$>$\\
\end{tabular}
\vspace*{1mm}

\noindent
\setlength{\tabcolsep}{0mm}
\begin{tabular}{ll}
\multicolumn{2}{l}{$<$printExpression$>$ ::=}\\
\hspace*{2mm} & 'none' $|$ $<$2dMatrixId$>$\\
\end{tabular}
\vspace*{1mm}

\noindent
\setlength{\tabcolsep}{0mm}
\begin{tabular}{ll}
\multicolumn{2}{l}{$<$constraint$>$ ::=}\\
\hspace*{2mm} & $<$reifiableConstraint$>$ $|$\\
               & reify($<$reifiableConstraint$>$, $<$var$>$) $|$\\
              & reifyimplies($<$reifiableConstraint$>$, $<$var$>$) $|$\\
              & table($<$varVectorExpression$>$, $<$tuples$>$) $|$\\
              & $<$watchSumConstraints$>$($<$varVectorExpression$>$, $<$varVectorExpression$>$) $|$\\
              & watchelement($<$varVectorExpression$>$, $<$var$>$, $<$var$>$) $|$\\
              & watchvecneq($<$varVectorExpression$>$, $<$varVectorExpression$>$) $|$\\
              & minusequal ($<$var$>$, $<$var$>$) $|$\\
             & litsumequal($<$varVectorExpression$>$, $<$literalConstVector$>$, $<$var$>$) \\
             
\end{tabular}
\vspace*{1mm}

\noindent
\setlength{\tabcolsep}{0mm}
\begin{tabular}{ll}
\multicolumn{2}{l}{$<$reifiableConstraint$>$ ::=}\\
\hspace*{2mm}              & allDiff($<$varVectorExpression$>$) $|$\\
             & $<$eqOrDiseqConstraint$>$ ($<$var$>$, $<$var$>$) $|$\\
              & element($<$varVectorExpression$>$, $<$var$>$, $<$var$>$) $|$\\
              & gacelement($<$varVectorExpression$>$, $<$var$>$, $<$var$>$) $|$\\
              & ineq($<$var$>$, $<$var$>$, $<$const$>$) $|$\\
              & $<$lexConstraint$>$ ($<$varVectorExpression$>$, $<$varVectorExpression$>$) $|$\\
              & $<$MinOrMaxConstraint$>$ ($<$varVectorExpression$>$, $<$var$>$) $|$\\
              & occurrence($<$varVectorExpression$>$, $<$const$>$, $<$const$>$) $|$\\ 
                       % used to be occurrence(varVectorexpression, const, var) but is different in source-code
              & product($<$varVectorExpression$>$, $<$var$>$) $|$\\
              & product($<$varVectorExpression$>$, $<$literalConstVector$>$, $<$var$>$) $|$\\
              & sum($<$varVectorExpression$>$, $<$var$>$) $|$ \\
              & $<$weightedsum$>$($<$varVectorExpression$>$, $<$constVectorExpression$>$, $<$var$>$)  
\end{tabular}

\noindent
\setlength{\tabcolsep}{0mm}
\begin{tabular}{ll}
\multicolumn{2}{l}{$<$varVectorExpression$>$ ::=}\\
\hspace*{2mm} & $<$literalVarVector$>$ $|$ $<$1dMatrixId$>$ $|$ $<$2dMatrixId$>$ $|$\\
              & $<$3dMatrixId$>$ $|$ $<$rowOrCol$>$($<$2dMatrixId$>$, $<$index$>$) $|$\\
              & $<$colOrRowXOrRowY$>$($<$3dMatrixId$>$, $<$index$>$, $<$index$>$)
\end{tabular}
}  % end of comment out region
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Important Notes and Changes}\label{sect_notes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection*{Changes}

The following changes have been made since the last version:

\begin{enumerate}
  \item \textbf{power constraint}: the \texttt{pow} constraint has been added.
  \item \textbf{table constraint}: there is a new implementation of the \texttt{table}
   constraint where new data structures are used. Details can be found 
   in the CPPOD-technical
   report\footnote{http://www.dcs.st-and.ac.uk/~cppod/publications/reports/cppod-19-2006.pdf}.
 \item \textbf{flags for variable ordering and preprocessing}
   Some flags have been added for preprocessing and variable
   ordering. Please note, that these flags are still in an
   experimental stage and are not optimised yet, so the default settings
   might solve your problems faster.
   \begin{itemize}
      \item \texttt{-varorder = <order>}\\
	{ \sc Minion}'s normal variable ordering uses information from  
        previous search nodes to avoid rechecking the same variable at later  
        search nodes. The variable orderings generated by \texttt{varorder} do not  
        do this, so are likely to be much slower for large numbers of  
        variables. This effect can be measured using the \texttt{static} varorder,  
        which is the same as the normal ordering except not using state from  
        previous nodes. \texttt{<order>} can be:\\
      \begin{tabular}{ll}
	& \\
	\texttt{sdf} & smallest domain first, then break ties with lex \\
	\texttt{sdf-random} & smallest domain first, break ties randomly\\
        \texttt{ldf} & Largest domain first\\
        \texttt{ldf-random} & largest domain first, break ties randomly\\
	\texttt{random} & random variable ordering\\
	\texttt{static} & normal ordering without caching \\
        & \\
      \end{tabular}
      \item \texttt{-sac-root}\\
	Perform SGAC at the first node. 
      \item \texttt{-ssac-root}\\
	Perform SSGAC at the first node. 
   \end{itemize}
\end{enumerate}



\subsection*{Notes}
\begin{enumerate}
 \item \textbf{Sparse discrete variables} are not implemented yet. 
   %\item \textbf{Reification using \texttt{reifyimply}} \\
   %There are problems with the reification of the constraints: 
   %allDifferent, diseq, occurence, weightedsumleq, weightedsumgeq, sumleq, sumgeq

  \item \textbf{Reification using \texttt{reify}} \\
    There are problems with the reification of the constraints: 
    diseq, element, gacelement, ineq, max, min, occurence, product

\end{enumerate}

%\subsection*{Known Bugs}
%The following \textbf{bugs} are known to {\sc MINION}.


\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example}\label{sect_example}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In Section~\ref{sect_matrix} we introduced, the $\langle 7, 7, 3, 3,
1\rangle$ BIBD instance. In this section we give a Minion specification
for this problem. All the text in \emph{italics} are added for
explanation, and are not part of the actual specification.

Note that the input starts with the fixed line ``MINION 1".   This is the version number of the 
{\em input format} and not of the version of {\sc Minion}.   This means that a given version 
of {\sc Minion} itself can immediately reject input if in a format intended for a later version.
We intend that the counter 1 will be incremented when a new format not readable is introduced, 
e.g. when a new constraint is introduced into the system.    Normally, after such a change,
{\sc Minion} will be able to read in instances defined under older versions, though this
is not guaranteed.


\begin{verbatim}
MINION 1
# Comments appear in consecutive lines after the first, starting 
# with # character. Each comment line starts with a #
# You can have as many as you like (including 0)
# But as soon as a line does not start with #, no more comments 
# may appear in the input
196
\end{verbatim}
\emph{there are 196 Boolean variables}
\begin{verbatim}
0
\end{verbatim}
\emph{there are 0 bounds variables}
\begin{verbatim}
0
\end{verbatim}
\emph{there are 0 bounds sparse variables}
\begin{verbatim}
0
\end{verbatim}
\emph{there are 0 discrete variables}
\begin{verbatim}
0
\end{verbatim}
\emph{there are 0 discrete sparse variables}

\emph{these are the variables to be searched upon...}
\begin{verbatim}
[x0,x1,x2,x3,x4,x5,x6,
x7,x8,x9,x10,x11,x12,x13,
x14,x15,x16,x17,x18,x19,x20,
x21,x22,x23,x24,x25,x26,x27,
x28,x29,x30,x31,x32,x33,x34,
x35,x36,x37,x38,x39,x40,x41,
x42,x43,x44,x45,x46,x47,x48
]
\end{verbatim}
\emph{...in the order in which the should be searched}
\begin{verbatim}
[a,a,a,a,a,a,a,
a,a,a,a,a,a,a,
a,a,a,a,a,a,a,
a,a,a,a,a,a,a,
a,a,a,a,a,a,a,
a,a,a,a,a,a,a,
a,a,a,a,a,a,a
]
\end{verbatim}

\emph{there are twenty-one 1-Dimensional matrices}
\begin{verbatim}
21
\end{verbatim}
\emph{this is the specification of which variables are in each matrix}
\begin{verbatim}
[x49, x50, x51, x52, x53, x54, x55]
[x56, x57, x58, x59, x60, x61, x62]
[x63, x64, x65, x66, x67, x68, x69]
[x70, x71, x72, x73, x74, x75, x76]
[x77, x78, x79, x80, x81, x82, x83]
[x84, x85, x86, x87, x88, x89, x90]
[x91, x92, x93, x94, x95, x96, x97]
[x98, x99, x100, x101, x102, x103, x104]
[x105, x106, x107, x108, x109, x110, x111]
[x112, x113, x114, x115, x116, x117, x118]
[x119, x120, x121, x122, x123, x124, x125]
[x126, x127, x128, x129, x130, x131, x132]
[x133, x134, x135, x136, x137, x138, x139]
[x140, x141, x142, x143, x144, x145, x146]
[x147, x148, x149, x150, x151, x152, x153]
[x154, x155, x156, x157, x158, x159, x160]
[x161, x162, x163, x164, x165, x166, x167]
[x168, x169, x170, x171, x172, x173, x174]
[x175, x176, x177, x178, x179, x180, x181]
[x182, x183, x184, x185, x186, x187, x188]
[x189, x190, x191, x192, x193, x194, x195]
\end{verbatim}
\emph{there is one 2-dimensional matrix}
\begin{verbatim}
1
\end{verbatim}
\emph{the structure of the 2-dimensional matrix, and the veariables involved}
\begin{verbatim}
[[x0, x1, x2, x3, x4, x5, x6],
[x7, x8, x9, x10, x11, x12, x13],
[x14, x15, x16, x17, x18, x19, x20],
[x21, x22, x23, x24, x25, x26, x27],
[x28, x29, x30, x31, x32, x33, x34],
[x35, x36, x37, x38, x39, x40, x41],
[x42, x43, x44, x45, x46, x47, x48]]
\end{verbatim}
\emph{there are 0 3-dimensional matrices}
\begin{verbatim}
0
\end{verbatim}
\emph{there is no objective function}
\begin{verbatim}
objective none
\end{verbatim}
\emph{display the BIBD when a solution is found. NB Generally, an arbitrary
`display' matrix can be defined to display the output in the manner of the
user's choice.}
\begin{verbatim}
print m0
\end{verbatim}
\emph{these are all the problem constraints}
\begin{verbatim}
sumleq(row(m0, 0), 3)
sumgeq(row(m0, 0), 3)
sumleq(row(m0, 1), 3)
sumgeq(row(m0, 1), 3)
sumleq(row(m0, 2), 3)
sumgeq(row(m0, 2), 3)
sumleq(row(m0, 3), 3)
sumgeq(row(m0, 3), 3)
sumleq(row(m0, 4), 3)
sumgeq(row(m0, 4), 3)
sumleq(row(m0, 5), 3)
sumgeq(row(m0, 5), 3)
sumleq(row(m0, 6), 3)
sumgeq(row(m0, 6), 3)
sumleq(col(m0, 0), 3)
sumgeq(col(m0, 0), 3)
sumleq(col(m0, 1), 3)
sumgeq(col(m0, 1), 3)
sumleq(col(m0, 2), 3)
sumgeq(col(m0, 2), 3)
sumleq(col(m0, 3), 3)
sumgeq(col(m0, 3), 3)
sumleq(col(m0, 4), 3)
sumgeq(col(m0, 4), 3)
sumleq(col(m0, 5), 3)
sumgeq(col(m0, 5), 3)
sumleq(col(m0, 6), 3)
sumgeq(col(m0, 6), 3)
product(x0, x7, x49)
product(x1, x8, x50)
product(x2, x9, x51)
product(x3, x10, x52)
product(x4, x11, x53)
product(x5, x12, x54)
product(x6, x13, x55)
sumleq(v0, 1)
sumgeq(v0, 1)
product(x0, x14, x56)
product(x1, x15, x57)
product(x2, x16, x58)
product(x3, x17, x59)
product(x4, x18, x60)
product(x5, x19, x61)
product(x6, x20, x62)
sumleq(v1, 1)
sumgeq(v1, 1)
product(x0, x21, x63)
product(x1, x22, x64)
product(x2, x23, x65)
product(x3, x24, x66)
product(x4, x25, x67)
product(x5, x26, x68)
product(x6, x27, x69)
sumleq(v2, 1)
sumgeq(v2, 1)
product(x0, x28, x70)
product(x1, x29, x71)
product(x2, x30, x72)
product(x3, x31, x73)
product(x4, x32, x74)
product(x5, x33, x75)
product(x6, x34, x76)
sumleq(v3, 1)
sumgeq(v3, 1)
product(x0, x35, x77)
product(x1, x36, x78)
product(x2, x37, x79)
product(x3, x38, x80)
product(x4, x39, x81)
product(x5, x40, x82)
product(x6, x41, x83)
sumleq(v4, 1)
sumgeq(v4, 1)
product(x0, x42, x84)
product(x1, x43, x85)
product(x2, x44, x86)
product(x3, x45, x87)
product(x4, x46, x88)
product(x5, x47, x89)
product(x6, x48, x90)
sumleq(v5, 1)
sumgeq(v5, 1)
product(x7, x14, x91)
product(x8, x15, x92)
product(x9, x16, x93)
product(x10, x17, x94)
product(x11, x18, x95)
product(x12, x19, x96)
product(x13, x20, x97)
sumleq(v6, 1)
sumgeq(v6, 1)
product(x7, x21, x98)
product(x8, x22, x99)
product(x9, x23, x100)
product(x10, x24, x101)
product(x11, x25, x102)
product(x12, x26, x103)
product(x13, x27, x104)
sumleq(v7, 1)
sumgeq(v7, 1)
product(x7, x28, x105)
product(x8, x29, x106)
product(x9, x30, x107)
product(x10, x31, x108)
product(x11, x32, x109)
product(x12, x33, x110)
product(x13, x34, x111)
sumleq(v8, 1)
sumgeq(v8, 1)
product(x7, x35, x112)
product(x8, x36, x113)
product(x9, x37, x114)
product(x10, x38, x115)
product(x11, x39, x116)
product(x12, x40, x117)
product(x13, x41, x118)
sumleq(v9, 1)
sumgeq(v9, 1)
product(x7, x42, x119)
product(x8, x43, x120)
product(x9, x44, x121)
product(x10, x45, x122)
product(x11, x46, x123)
product(x12, x47, x124)
product(x13, x48, x125)
sumleq(v10, 1)
sumgeq(v10, 1)
product(x14, x21, x126)
product(x15, x22, x127)
product(x16, x23, x128)
product(x17, x24, x129)
product(x18, x25, x130)
product(x19, x26, x131)
product(x20, x27, x132)
sumleq(v11, 1)
sumgeq(v11, 1)
product(x14, x28, x133)
product(x15, x29, x134)
product(x16, x30, x135)
product(x17, x31, x136)
product(x18, x32, x137)
product(x19, x33, x138)
product(x20, x34, x139)
sumleq(v12, 1)
sumgeq(v12, 1)
product(x14, x35, x140)
product(x15, x36, x141)
product(x16, x37, x142)
product(x17, x38, x143)
product(x18, x39, x144)
product(x19, x40, x145)
product(x20, x41, x146)
sumleq(v13, 1)
sumgeq(v13, 1)
product(x14, x42, x147)
product(x15, x43, x148)
product(x16, x44, x149)
product(x17, x45, x150)
product(x18, x46, x151)
product(x19, x47, x152)
product(x20, x48, x153)
sumleq(v14, 1)
sumgeq(v14, 1)
product(x21, x28, x154)
product(x22, x29, x155)
product(x23, x30, x156)
product(x24, x31, x157)
product(x25, x32, x158)
product(x26, x33, x159)
product(x27, x34, x160)
sumleq(v15, 1)
sumgeq(v15, 1)
product(x21, x35, x161)
product(x22, x36, x162)
product(x23, x37, x163)
product(x24, x38, x164)
product(x25, x39, x165)
product(x26, x40, x166)
product(x27, x41, x167)
sumleq(v16, 1)
sumgeq(v16, 1)
product(x21, x42, x168)
product(x22, x43, x169)
product(x23, x44, x170)
product(x24, x45, x171)
product(x25, x46, x172)
product(x26, x47, x173)
product(x27, x48, x174)
sumleq(v17, 1)
sumgeq(v17, 1)
product(x28, x35, x175)
product(x29, x36, x176)
product(x30, x37, x177)
product(x31, x38, x178)
product(x32, x39, x179)
product(x33, x40, x180)
product(x34, x41, x181)
sumleq(v18, 1)
sumgeq(v18, 1)
product(x28, x42, x182)
product(x29, x43, x183)
product(x30, x44, x184)
product(x31, x45, x185)
product(x32, x46, x186)
product(x33, x47, x187)
product(x34, x48, x188)
sumleq(v19, 1)
sumgeq(v19, 1)
product(x35, x42, x189)
product(x36, x43, x190)
product(x37, x44, x191)
product(x38, x45, x192)
product(x39, x46, x193)
product(x40, x47, x194)
product(x41, x48, x195)
sumleq(v20, 1)
sumgeq(v20, 1)
\end{verbatim}
\emph{these are symmetry breaking constraints - double lex}
\begin{verbatim}
lexleq(row(m0, 0), row(m0, 1))
lexleq(row(m0, 1), row(m0, 2))
lexleq(row(m0, 2), row(m0, 3))
lexleq(row(m0, 3), row(m0, 4))
lexleq(row(m0, 4), row(m0, 5))
lexleq(row(m0, 5), row(m0, 6))
lexleq(col(m0, 0), col(m0, 1))
lexleq(col(m0, 1), col(m0, 2))
lexleq(col(m0, 2), col(m0, 3))
lexleq(col(m0, 3), col(m0, 4))
lexleq(col(m0, 4), col(m0, 5))
lexleq(col(m0, 5), col(m0, 6))
\end{verbatim}

\end{small}



\end{document}

\section{Introduction}
Problems often consist of choices. Making a choice which is compatible with all other choices made, and optimal is difficult. Constraint programming (CP) is the branch of Artificial Intelligence, where computers help us to make these choices. 

Constraint programming is a multidisciplinary technology combining computer science, operational research and mathematics. Constraints arise in design \& configuration, planning \& scheduling, diagnosis \& testing, and in many other contexts. CP can solve problems in telecommunication, e-commerce, electronics, bioinformatics, transportation, network management, supply chain management, and many other fields.

A constraint program consists of a set of variables, a set of possible values, for each variable and a set of constraints. For example, the problem might be to fit components (values) to circuit boards (variables), subject to the constraint that no two components can be overlapping. A solution to a CSP is an allocation of values to variables such that none of the constraints are violated.

{\sc Minion}, is a program for finding solutions to constraint problems. {\sc Minion}, can find one solution to a problem, all solutions to a problem, or an optimsed (good) solution to a problem, subject to an optimising criteria. This document outlines, how the model of a CP instance should be formatted so that {\sc Minion} can accept it as input. Modelling means to move from a natural language specification of a problem, into a CSP instance consisting only of variables, values and constraints. It may be possible to find more than one model of a problem, in which case a model is sought that can efficiently lead to a solution through CSP solving techniques. The {\sc Minion} input language, is designed to be written by a computer program. Users should find it easy to write programs, in the language of their choice, which output correct {\sc Minion} specifications. However, we recognise that most CP practitioners, may wish to experiment by hand first, so the input language is designed in such a way that simple instances can be written and read by hand.
 
It should be noted that this document does not explain, the internal workings of {\sc Minion}, nor does it explain how the programmer can add features.

\section{Matrix Models}\label{sect_matrix}
{\sc Minion} is a general-purpose constraint solver, with an expressive input language based on the common constraint modelling device of matrix models. In this context a matrix, is a $n$-dimensional object, which can be used to store CSP variables, matrices allow ease of reference to these variables. In CSP a matrix formulation employs one or more matrices of
decision variables, with constraints typically imposed on the rows, columns and planes of the matrices. 

To illustrate, consider the {\em Balanced Incomplete Block Design}
(BIBD, CSPLib problem 28), which is defined as follows: Given a
5-tuple of positive integers, $\langle v$, $b$, $r$, $k$,
$\lambda\rangle$, assign each of $v$ objects to $b$ blocks such that
each block contains $k$ distinct objects, each object occurs in
exactly $r$ different blocks and every two distinct objects occur
together in exactly $\lambda$ blocks. Despite its simplicity, the BIBD
has important practical applications, such as cryptography and
experimental design.




